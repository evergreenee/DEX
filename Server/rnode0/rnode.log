2023-11-19 03:51:01,802 [INFO ] [main                ] [coop.rchain.node.Main$       ]- RChain Node 0.13.0-alpha3 (c766347c6df06d813f802ae9e4ca1186647cf070)
2023-11-19 03:51:01,805 [INFO ] [main                ] [coop.rchain.node.Main$       ]- Starting with profile default
2023-11-19 03:51:01,806 [INFO ] [main                ] [coop.rchain.node.Main$       ]- Using configuration file: /home/nardack/Desktop/DEX/Server/config.conf
2023-11-19 03:51:01,806 [INFO ] [main                ] [coop.rchain.node.Main$       ]- Running on network: testnet
2023-11-19 03:51:02,016 [INFO ] [main                ] [c.r.node.NodeEnvironment$    ]- Using data dir: /home/nardack/Desktop/DEX/Server/rnode0
2023-11-19 03:51:02,021 [INFO ] [main                ] [t.GenerateCertificateIfAbsent]- No certificate found at path rnode0/node.certificate.pem
2023-11-19 03:51:02,023 [INFO ] [main                ] [t.GenerateCertificateIfAbsent]- Generating a X.509 certificate for the node
2023-11-19 03:51:02,024 [INFO ] [main                ] [t.GenerateCertificateIfAbsent]- Generating a PEM secret key for the node
2023-11-19 03:51:02,269 [DEBUG] [main                ] [jdk.event.security           ]- X509Certificate: Alg:SHA256withECDSA, Serial:e36c07d5eecb9686, Subject:CN=37a7a51e0bf11dd13dfc7723b31b2e7ea84fd4e2, Issuer:CN=37a7a51e0bf11dd13dfc7723b31b2e7ea84fd4e2, Key type:EC, Length:256, Cert Id:1986340920, Valid from:2023/11/19 上午11:51, Valid until:2024/11/18 上午11:51
2023-11-19 03:51:02,467 [DEBUG] [main                ] [c.r.s.LmdbStoreManagerImpl   ]- Creating LMDB environment: rnode0/dagstorage
2023-11-19 03:51:02,641 [DEBUG] [main                ] [c.r.s.LmdbStoreManagerImpl   ]- Creating LMDB database: last-finalized-block, env: rnode0/dagstorage
2023-11-19 03:51:02,663 [INFO ] [main                ] [c.r.b.dag.BlockMetadataStore$]- Building in-memory blockMetadataStore.
2023-11-19 03:51:02,665 [DEBUG] [main                ] [c.r.s.LmdbStoreManagerImpl   ]- Creating LMDB database: block-metadata, env: rnode0/dagstorage
2023-11-19 03:51:02,673 [INFO ] [main                ] [c.r.b.dag.BlockMetadataStore$]- Reading data from blockMetadataStore done.
2023-11-19 03:51:02,698 [INFO ] [main                ] [c.r.b.dag.BlockMetadataStore$]- Successfully built in-memory blockMetadataStore.
2023-11-19 03:51:02,711 [DEBUG] [main                ] [c.r.s.LmdbStoreManagerImpl   ]- Creating LMDB environment: rnode0/casperbuffer
2023-11-19 03:51:02,712 [DEBUG] [main                ] [c.r.s.LmdbStoreManagerImpl   ]- Creating LMDB database: parents-map, env: rnode0/casperbuffer
2023-11-19 03:51:02,790 [DEBUG] [main                ] [c.r.s.LmdbStoreManagerImpl   ]- Creating LMDB environment: rnode0/eval/history
2023-11-19 03:51:02,792 [DEBUG] [main                ] [c.r.s.LmdbStoreManagerImpl   ]- Creating LMDB database: eval-roots, env: rnode0/eval/history
2023-11-19 03:51:02,822 [DEBUG] [main                ] [c.r.s.LmdbStoreManagerImpl   ]- Creating LMDB database: eval-history, env: rnode0/eval/history
2023-11-19 03:51:04,140 [DEBUG] [main                ] [c.r.s.LmdbStoreManagerImpl   ]- Creating LMDB environment: rnode0/rspace/history
2023-11-19 03:51:04,141 [DEBUG] [main                ] [c.r.s.LmdbStoreManagerImpl   ]- Creating LMDB database: rspace-roots, env: rnode0/rspace/history
2023-11-19 03:51:04,146 [DEBUG] [main                ] [c.r.s.LmdbStoreManagerImpl   ]- Creating LMDB database: rspace-history, env: rnode0/rspace/history
2023-11-19 03:51:04,504 [DEBUG] [node-runner-18      ] [c.r.s.LmdbStoreManagerImpl   ]- Creating LMDB database: blocks-approved, env: rnode0/dagstorage
2023-11-19 03:51:04,509 [INFO ] [node-runner-18      ] [c.r.c.e.CasperLaunch$$anon$1 ]- Approved block not found, taking part in ceremony as ceremony master
2023-11-19 03:51:04,528 [INFO ] [node-runner-18      ] [c.r.casper.util.VaultParser$ ]- Parsing wallets file rnode0/genesis/wallets.txt.
2023-11-19 03:51:04,661 [INFO ] [node-runner-18      ] [c.r.casper.util.VaultParser$ ]- Wallet loaded: 1111Wbd8KLeWBVsxByF9iksJ4QRRjEF3nq1ScgAw7bMbtomxHsqqd,1000000000000000,0
2023-11-19 03:51:04,664 [INFO ] [node-runner-18      ] [c.r.casper.util.VaultParser$ ]- Wallet loaded: 1111235s1WgxZjTRi1McWXNtys53mhUSmXoRq72YMzGL6v12fkLFHv,100000000,0
2023-11-19 03:51:04,665 [INFO ] [node-runner-18      ] [c.r.casper.util.VaultParser$ ]- Wallet loaded: 11112Bqt2LBKM2k5UbS9twPzf7VzhCuNt8Tj1ncVQruA1hhMDJWpfB,1000,0
2023-11-19 03:51:04,689 [INFO ] [node-runner-18      ] [c.r.casper.util.BondsParser$ ]- Parsing bonds file rnode0/genesis/bonds.txt.
2023-11-19 03:51:04,703 [INFO ] [node-runner-18      ] [c.r.casper.util.BondsParser$ ]- Bond loaded 04be064356846e36e485408df50b877dd99ba406d87208add4c92b3c7d4e4c663c2fbc6a1e6534c7e5c0aec00b26486fad1daf20079423b7c8ebffbbdff3682b58 => 100000000000
2023-11-19 03:51:04,706 [INFO ] [node-runner-18      ] [c.r.casper.util.BondsParser$ ]- Bond loaded 042e13eadc97fb886eed6ba8fda1f1aa5d1cb653f1fcb765cf03c9cfdcba01aa79f367ec0dd86bf8a0508110aa97b66fdf7139fa8bbac86a8b9c1dac20e656574c => 1000000
2023-11-19 03:51:04,710 [INFO ] [node-runner-18      ] [c.r.casper.util.BondsParser$ ]- Bond loaded 049ab5d17cda550253f76425d33c69891a99a6d00d7b190767305e493ce5b35f823a1ec144c9242c1ceb5e915095dabaff30f6fea48c5dcb213c6fb7a87050f657 => 1000000
2023-11-19 03:51:04,713 [INFO ] [node-runner-18      ] [c.r.casper.util.BondsParser$ ]- Bond loaded 04d34d5f438e9db72725489b54e8012f856d9a26e3ab4dea6e5938bdf91b7d7952e6ebb263450315d71176d1718681fd9814c330cfac07e8b9b8d84e6c72dfdd78 => 1000000
2023-11-19 03:51:06,036 [DEBUG] [node-runner-23      ] [c.r.s.LmdbStoreManagerImpl   ]- Creating LMDB environment: rnode0/rspace/cold
2023-11-19 03:51:06,037 [DEBUG] [node-runner-23      ] [c.r.s.LmdbStoreManagerImpl   ]- Creating LMDB database: rspace-cold, env: rnode0/rspace/cold
2023-11-19 03:51:16,342 [DEBUG] [node-runner-29      ] [c.r.s.LmdbStoreManagerImpl   ]- Creating LMDB database: mergeable-channel-cache, env: rnode0/dagstorage
2023-11-19 03:51:16,680 [INFO ] [node-runner-29      ] [c.r.node.runtime.NodeRuntime ]- Starting stand-alone node.
2023-11-19 03:51:17,703 [INFO ] [node-runner-29      ] [c.r.n.r.ServersInstances$    ]- HTTP API server started at 192.168.59.133:40403
2023-11-19 03:51:17,717 [INFO ] [node-runner-29      ] [c.r.n.r.ServersInstances$    ]- Admin HTTP API server started at 192.168.59.133:40405
2023-11-19 03:51:17,787 [INFO ] [node-runner-26      ] [ocol$ApproveBlockProtocolImpl]- Starting execution of ApprovedBlockProtocol. Waiting for 0 approvals from genesis validators.
2023-11-19 03:51:17,788 [INFO ] [node-runner-26      ] [ocol$ApproveBlockProtocolImpl]- Self-approving genesis block.
2023-11-19 03:51:17,792 [DEBUG] [node-runner-29      ] [.r.c.e.BlockRetriever$$anon$1]- Running BlockRetriever maintenance (0 items unexpired).
2023-11-19 03:51:17,804 [INFO ] [node-runner-26      ] [ocol$ApproveBlockProtocolImpl]- Sending ApprovedBlock 3189b5db12... to peers...
2023-11-19 03:51:17,841 [INFO ] [node-runner-26      ] [ocol$ApproveBlockProtocolImpl]- Finished execution of ApprovedBlockProtocol
2023-11-19 03:51:17,927 [INFO ] [node-runner-28      ] [c.r.n.r.ServersInstances$    ]- Internal API server started at 192.168.59.133:40402
2023-11-19 03:51:17,927 [INFO ] [node-runner-24      ] [c.r.n.r.ServersInstances$    ]- Kademlia RPC server started at 192.168.59.133:40404
2023-11-19 03:51:17,927 [INFO ] [node-runner-27      ] [c.r.n.r.ServersInstances$    ]- External API server started at 192.168.59.133:40401
2023-11-19 03:51:17,944 [DEBUG] [node-runner-18      ] [jdk.event.security           ]- X509Certificate: Alg:SHA256withRSA, Serial:752bd03efd500194, Subject:CN=example.com, Issuer:CN=example.com, Key type:RSA, Length:2048, Cert Id:1467855822, Valid from:2018/4/7 上午6:06, Valid until:10000/1/1 上午7:59
2023-11-19 03:51:18,083 [INFO ] [node-runner-18      ] [c.r.n.r.ServersInstances$    ]- Listening for traffic on rnode://37a7a51e0bf11dd13dfc7723b31b2e7ea84fd4e2@192.168.59.133?protocol=40400&discovery=40404.
2023-11-19 03:51:18,698 [DEBUG] [node-runner-25      ] [c.r.s.LmdbStoreManagerImpl   ]- Creating LMDB environment: rnode0/blockstorage
2023-11-19 03:51:18,700 [DEBUG] [node-runner-25      ] [c.r.s.LmdbStoreManagerImpl   ]- Creating LMDB database: blocks, env: rnode0/blockstorage
2023-11-19 03:51:18,716 [WARN ] [node-runner-25      ] [.b.d.BlockDagKeyValueStorage$]- Block Block #0 (3189b5db12...) with empty parents (supposedly genesis) sender is empty.
2023-11-19 03:51:18,731 [DEBUG] [node-runner-25      ] [c.r.s.LmdbStoreManagerImpl   ]- Creating LMDB database: deploy-index, env: rnode0/dagstorage
2023-11-19 03:51:18,738 [DEBUG] [node-runner-25      ] [c.r.s.LmdbStoreManagerImpl   ]- Creating LMDB database: latest-messages, env: rnode0/dagstorage
2023-11-19 03:51:18,755 [DEBUG] [node-runner-25      ] [c.r.s.LmdbStoreManagerImpl   ]- Creating LMDB database: invalid-blocks, env: rnode0/dagstorage
2023-11-19 03:51:18,783 [INFO ] [node-runner-25      ] [c.r.casper.engine.Engine$    ]- Making a transition to Running state. Approved Block #0 (3189b5db12...) with empty parents (supposedly genesis)
2023-11-19 03:51:18,813 [INFO ] [node-runner-25      ] [c.r.c.util.comm.CommUtilOps  ]- Requested fork tip from peers
2023-11-19 03:51:21,220 [DEBUG] [node-runner-23      ] [c.r.c.safety.CliqueOracle$   ]- Calculating fault tolerance for 3189b5db126990481fd56ee8cfeaf6437a920ddc699ae0dd39b378947d728786.
2023-11-19 03:51:21,220 [DEBUG] [node-runner-28      ] [c.r.c.safety.CliqueOracle$   ]- Calculating fault tolerance for 3189b5db126990481fd56ee8cfeaf6437a920ddc699ae0dd39b378947d728786.
2023-11-19 03:51:21,272 [DEBUG] [node-runner-28      ] [c.r.s.LmdbStoreManagerImpl   ]- Creating LMDB database: equivocation-tracker, env: rnode0/dagstorage
2023-11-19 03:51:21,576 [DEBUG] [node-runner-24      ] [c.r.s.LmdbStoreManagerImpl   ]- Creating LMDB environment: rnode0/deploystorage
2023-11-19 03:51:21,577 [DEBUG] [node-runner-24      ] [c.r.s.LmdbStoreManagerImpl   ]- Creating LMDB database: deploy_storage, env: rnode0/deploystorage
2023-11-19 03:51:21,581 [INFO ] [node-runner-18      ] [c.r.c.MultiParentCasperImpl  ]- Received DeployData #1700365880805 -- new
  NecVault, rs(`rho:registry:insertSigned:secp256k1`), uriOut,
  rl(`rho:registry:lookup`), RevAddress(`rho:rev:address`),
  insertArbitrary(`rho:registry:insertArbitrary`),
  stdout(`rho:io:stdout`), deployId(`rho:rchain:deployId`),
  MakeMintCh, AuthKeyCh, EitherCh, TreeHashMapCh, RevVaultCh, 
  _makeVault,
  _newVault,
  _create,
  _necVault,
  _transferTemplate,
  _depositTemplate
in {
  rl!(`rho:rchain:makeMint`, *MakeMintCh) |
  rl!(`rho:rchain:authKey`, *AuthKeyCh) |
  rl!(`rho:lang:either`, *EitherCh) |
  rl!(`rho:lang:treeHashMap`, *TreeHashMapCh) |
  rl!(`rho:rchain:revVault`, *RevVaultCh) |
  for (@(_, MakeMint) <- MakeMintCh;
       @(_, AuthKey)  <- AuthKeyCh;
       @(_, Either)   <- EitherCh;
       @(_, RevVault) <- RevVaultCh; 
       TreeHashMap    <- TreeHashMapCh) {
    new mintCh, revMapStore, necMapStore, initVault, unf, authKeyCh, revHouseAddrCh in {
      // generate revHouse for holding deposited REV 
      RevAddress!("fromUnforgeable", *unf, *revHouseAddrCh) |
      @RevVault!("unforgeableAuthKey", *unf, *authKeyCh) |
      for (@revHouseVaultAuthKey <- authKeyCh;  @revHouseAddr <- revHouseAddrCh) {
        new revHouseVaultCh, _depositList in {
          @RevVault!("findOrCreate", revHouseAddr, *revHouseVaultCh) |
          deployId!(["revHouseAddr : ",revHouseAddr])|
          // mapstore for depositing REV
          TreeHashMap!("init", 2, *revMapStore) |
          // mapstore for nec token
          TreeHashMap!("init", 2, *necMapStore)| 
          for (@(true, revHouseVault) <- revHouseVaultCh; @revMap <- revMapStore; @necMap <- necMapStore) {
            @MakeMint!(*mintCh) |
            for (mint <- mintCh) {
              contract initVault(name, @address, @initialAmount) = {
                new purseCh in {
                  mint!("makePurse", initialAmount, *purseCh) |
                  for (purse <- purseCh) {
                    _newVault!(*name, address, *purse)  
                  }
                }
              } |
              contract NecVault(@"test",res) = {
                res!("test success")
              }
              |
              contract NecVault(@"deployerAuthKey", deployerId, ret) = {
                new DeployerIdOps(`rho:rchain:deployerId:ops`),
                    revAddrCh, deployerPubKeyBytesCh
                in {
                  DeployerIdOps!("pubKeyBytes", *deployerId, *deployerPubKeyBytesCh) |
                  for (@deployerPubKeyBytes <- deployerPubKeyBytesCh) {
                    RevAddress!("fromPublicKey", deployerPubKeyBytes, *revAddrCh) |
                    for (@deployerRevAddress <- revAddrCh) {
                      @AuthKey!("make", (*_necVault, deployerRevAddress), *ret)
                    }
                  }
                }
              } |
              contract NecVault(@"unforgeableAuthKey", unf, ret) = {
                new revAddrCh in {
                  RevAddress!("fromUnforgeable", *unf, *revAddrCh) |
                  for (@unfRevAddress <- revAddrCh) {
                    @AuthKey!("make", (*_necVault, unfRevAddress), *ret)
                  }
                }
              } |
              contract NecVault(@"findOrCreate", @revAddress, retCh) = {
                new revAddressValidCh, revAddressValidEitherCh in {
                  RevAddress!("validate", revAddress, *revAddressValidCh) |
                  @Either!("fromNillableError <-", *revAddressValidCh, *revAddressValidEitherCh) |
                  for (@revAddressEither <- revAddressValidEitherCh) {
                    match revAddressEither {
                      (false, _) => {
                        retCh!(revAddressEither)
                      }
                      _ => {
                        new createVault, vaultCh, getVaultCh in {
                          TreeHashMap!("get", necMap, revAddress, *getVaultCh) |
                          for (@vault <- getVaultCh) {
                            if (vault != Nil) {
                              retCh!((true, vault))
                            } else {
                              _create!(revAddress, *createVault, *vaultCh) |
                              for (vaultRetCh <- createVault) {
                                _makeVault!(revAddress, 0, *vaultRetCh) |
                                for (@eitherVault <- vaultCh) {
                                  retCh!(eitherVault)
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              } |

              contract NecVault(@"deposit", @amount, @rate, retCh) = {
                new DeployerIdOps(`rho:rchain:deployerId:ops`),
                    revAddrCh, deployerPubKeyBytesCh, deployerId(`rho:rchain:deployerId`)  
                in {
                  DeployerIdOps!("pubKeyBytes", *deployerId, *deployerPubKeyBytesCh) |
                  for (@deployerPubKeyBytes <- deployerPubKeyBytesCh) {
                    RevAddress!("fromPublicKey", deployerPubKeyBytes, *revAddrCh) |
                    for (@deployerRevAddress <- revAddrCh) {
                      new vaultCh, revVaultkeyCh in {
                        @RevVault!("findOrCreate", deployerRevAddress, *vaultCh) |
                        @RevVault!("deployerAuthKey", *deployerId, *revVaultkeyCh) |
                        for (@(true, vault) <- vaultCh; key <- revVaultkeyCh) {
                          // TODO: if the amount is below 10 REV, won't trigger.
                          new resultCh, ackCh, blockData(`rho:block:data`), tCh in {
                            @vault!("transfer", revHouseAddr, amount, *key, *resultCh) |
                            blockData!(*tCh) |
                            for (@result <- resultCh; @_, @t, @_ <- tCh) {
                              // TODO: If transfer failed,...
                              _depositList!("deposit", deployerRevAddress, {"timestamp":t,"amount":amount}, *ackCh)|
                              // send NEC
                              new createVault, necVaultCh, balanceCh, vaultCh, vaultCh, getVaultCh in {
                                TreeHashMap!("get", necMap, deployerRevAddress, *getVaultCh) |
                                for (@vault <- getVaultCh) {
                                  if (vault != Nil) {
                                    @vault!("balance", *balanceCh)| 
                                    for (@balance <- balanceCh) {
                                      _create!(deployerRevAddress, *createVault, *necVaultCh) |
                                      for (vaultRetCh <- createVault) {
                                        _makeVault!(deployerRevAddress, amount / rate + balance, *vaultRetCh) |
                                        for (@eitherVault <- necVaultCh) {
                                          retCh!(eitherVault)
                                        }
                                      }
                                    }      
                                  } else {
                                    _create!(deployerRevAddress, *createVault, *necVaultCh) |
                                    for (vaultRetCh <- createVault) {
                                      _makeVault!(deployerRevAddress, amount / rate, *vaultRetCh) |
                                      for (@eitherVault <- necVaultCh) {
                                        retCh!(eitherVault)
                                      }
                                    }  
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  } 
                }       
              } |

            //   contract NecVault(@"withdraw", retCh) = {
            //     new DeployerIdOps(`rho:rchain:deployerId:ops`),
            //         revAddrCh, deployerPubKeyBytesCh, RevVaultCh, deployerId(`rho:rchain:deployerId`), getBalanceCh  
            //     in {
            //       DeployerIdOps!("pubKeyBytes", *deployerId, *deployerPubKeyBytesCh) |
            //       for (@deployerPubKeyBytes <- deployerPubKeyBytesCh) {
            //         RevAddress!("fromPublicKey", deployerPubKeyBytes, *revAddrCh) |
            //         for (@deployerRevAddress <- revAddrCh) {                         
            //           _depositList!("withdraw", deployerRevAddress, *retCh)
            //         }        
            //       }
            //     } 
            //   } |  

              contract _depositList(@"deposit", @deployerRevAddress, @item, ackCh) = {
                new listCh in {
                  TreeHashMap!("get", revMap, deployerRevAddress, *listCh) |
                  for (@list <- listCh) {
                    if(list == Nil) {
                      TreeHashMap!("set", revMap, deployerRevAddress, [item], *ackCh) 
                    }else{
                      TreeHashMap!("set", revMap, deployerRevAddress, list ++ [item], *ackCh) 
                    }

                  }                
                }  
              } |

            //   contract _depositList(@"withdraw", @deployerRevAddress, retCh) = {
            //     new blockData(`rho:block:data`), tCh, _remove, liCh, ret in {
            //       blockData!(*tCh) |
            //       TreeHashMap!("get", revMap, deployerRevAddress, *liCh) |
            //       for (@_, @t, @_ <- tCh; @li <- liCh) {
            //         if (li == [] or li == Nil) {
            //           deployId!("No record found!")
            //         } else{
            //           _remove!(t, li, *ret)
            //           |deployId!(["list: ", li])
            //         }
            //       }|
            //       contract _remove (newTimeStamp, items, ret) = {
            //         new resultCh, ack, removeAck in {
            //           if(*items != []){
            //             if (*items.nth(0).get("timestamp") < (*newTimeStamp - 200000)) {
            //               @revHouseVault!("transfer", deployerRevAddress, *items.nth(0).get("amount"), revHouseVaultAuthKey, *resultCh) |
            //               for (@res <- resultCh) {
            //                 TreeHashMap!("set", revMap, deployerRevAddress, *items.slice(1,*items.length()), *ack) |
            //                 for (@ackn <- ack) {
            //                   _remove!( *newTimeStamp, *items.slice(1,*items.length()), *removeAck)|
            //                   ret!(true)
            //                   |
            //                   new re1 in {
            //                     TreeHashMap!("get", revMap, deployerRevAddress, *re1) |
            //                     for (@r <- re1) {
            //                       deployId!(["The removing result: ", r])
            //                     }
            //                   }  
            //                 }
            //               }
            //             }else{
            //               ret!(true)|
            //               retCh!(true)|
            //               new re in {
            //                 TreeHashMap!("get", revMap, deployerRevAddress, *re) |
            //                 for (@lis <- re) {
            //                     deployId!(["Final result:", lis])
            //                   }
            //               }    
            //             } 
            //           }                      
            //         }       
            //       }  
            //     }
            //   } |  
              contract _create(@revAddress, constructor, retCh) = {
                // The vault was not found, create a new one and set it in the necMap.
                new resCh, ackCh in {
                  constructor!(*resCh) |
                  for (@eitherVault <- resCh) {
                    match eitherVault {
                      (true, vault) => {
                        TreeHashMap!("set", necMap, revAddress, vault, *ackCh) |
                        for (_ <- ackCh) {
                          retCh!(eitherVault)
                        }
                      }
                      (false, _)    => {
                        retCh!(eitherVault)
                      }
                    }
                  }
                }
              } |
              contract _makeVault(@ownerRevAddress, @initialAmount, ret) = {
                new revAddrCh, eitherRevAddrCh, purseCh, eitherPurseCh, mkVault in {
                  @Either!("fromNillable", ownerRevAddress, "Required `revAddress` parameter was Nil", *eitherRevAddrCh) |
                  mint!("makePurse", initialAmount, *purseCh) |
                  @Either!("fromNillable <-", *purseCh, "Couldn't create purse", *eitherPurseCh) |
                  @Either!("map2 <-", *eitherRevAddrCh, *eitherPurseCh,
                    for (@addr, purse, r <- mkVault) {
                      new necVault in {
                        _newVault!(*necVault, addr, *purse) |
                        r!(bundle+{*necVault})
                      }
                    },
                    *ret
                  )
                }
              } |
              contract _newVault(necVault, @ownRevAddress, purse) = {
                new logStore in {
                  logStore!(Nil) |
                  contract necVault(@"balance", ret) = {
                    purse!("getBalance", *ret)
                  } |
                  contract necVault(@"transfer", @revAddress, @amount, authKey, ret) = {
                    new ret2 in {
                      _transferTemplate!(ownRevAddress, *purse, revAddress, amount, *authKey, *ret2) |
                      for (@result <- ret2) {
                        ret!(result) |
                        for (logCh <<- logStore) {
                          if (Nil != *logCh) {
                            new bd(`rho:block:data`), bdCh in {
                              bd!(*bdCh) |
                              for (@blockNumber, @timestamp, @sender <- bdCh) {
                                logCh!(["transfer", revAddress, amount, result, blockNumber, timestamp, sender])
                              }
                            }
                          }
                        }
                      }
                    }
                  } |
                  contract necVault(@"setLog", logCh, authKey, ret) = {
                    new authKeyValidCh in {
                      @AuthKey!("check", *authKey, (*_necVault, ownRevAddress), *authKeyValidCh) |
                      for (@result <- authKeyValidCh) {
                        if (result) {
                          new ack in {
                            for (_ <- logStore) {
                              logStore!(*logCh) |
                              purse!("setLog", *logCh, *ack) |
                              for (_ <- ack) {
                                ret!(true)
                              }
                            }
                          }
                        } else {
                          ret!(false)
                        }
                      }
                    }
                  } |
                  contract @{ownRevAddress | bundle0{*_necVault}}(@"_deposit", depositPurse, retCh) = {
                    _depositTemplate!(*purse, *depositPurse, *retCh)
                  }
                }
              } |
              contract _transferTemplate(@ownRevAddress, purse, @revAddress, @amount, authKey, ret) = {
                new revAddressValid, revAddressValidEither, amountNonNegative,
                    authKeyValidCh, authKeyValidEitherCh,
                    parametersOkCh, parametersAndAuthOkCh,
                    split, eitherPurseCh, doDeposit
                in {
                  RevAddress!("validate", revAddress, *revAddressValid) |
                  @Either!("fromNillableError <-", *revAddressValid, *revAddressValidEither) |
                  @Either!("fromBoolean", amount >= 0, "Amount must be non-negative", *amountNonNegative) |
                  @AuthKey!("check", *authKey, (*_necVault, ownRevAddress), *authKeyValidCh) |
                  @Either!("fromBoolean <-", *authKeyValidCh, "Invalid AuthKey", *authKeyValidEitherCh) |
                  @Either!("productR <-", *revAddressValidEither, *amountNonNegative, *parametersOkCh) |
                  @Either!("productR <-", *parametersOkCh, *authKeyValidEitherCh, *parametersAndAuthOkCh) |
                  @Either!("flatMap <-", *parametersAndAuthOkCh, *split, *eitherPurseCh) |
                  for (_, retCh <- split) {
                    new amountPurseCh in {
                      purse!("split", amount, *amountPurseCh) |
                      @Either!("fromSingletonList <-", *amountPurseCh, "Insufficient funds", *retCh)
                    }
                  } |
                  @Either!("flatMap <-", *eitherPurseCh, *doDeposit, *ret) |
                  for (@p, retCh <- doDeposit) {
                    @{revAddress | bundle0{*_necVault}}!("_deposit", p, *retCh)
                  }
                }
              } |
              contract _depositTemplate(toPurse, fromPurse, retCh) = {
                new amountCh, depositSuccessCh in {
                  fromPurse!("getBalance", *amountCh) |
                  for (@amount <- amountCh) {
                    toPurse!("deposit", amount, *fromPurse, *depositSuccessCh) |
                    @Either!("fromBoolean <-", *depositSuccessCh, "BUG FOUND: purse deposit failed", *retCh)
                  }
                }
              } 
              |
              insertArbitrary!(bundle+{*NecVault}, *uriOut) |
              for(@uri <- uriOut) {
                stdout!("NEC here:")|
                stdout!(uri)|
                deployId!(uri)// |
              }
            }
          }
        }
      }
    }
  }
}      , Sig: 3044022042bd59ba6ac8...a6cff6ed82cac07733b3, SigAlgorithm: secp256k1, ValidAfterBlockNumber: -1
2023-11-19 03:51:21,581 [INFO ] [node-runner-24      ] [c.r.c.MultiParentCasperImpl  ]- Received DeployData #1700365880804 -- new
  BulletVault, rs(`rho:registry:insertSigned:secp256k1`), uriOut,
  rl(`rho:registry:lookup`), RevAddress(`rho:rev:address`),
  insertArbitrary(`rho:registry:insertArbitrary`),
  stdout(`rho:io:stdout`), deployId(`rho:rchain:deployId`),
  MakeMintCh, AuthKeyCh, EitherCh, TreeHashMapCh, RevVaultCh, 
  _makeVault,
  _newVault,
  _create,
  _bulletVault,
  _transferTemplate,
  _depositTemplate
in {
  rl!(`rho:rchain:makeMint`, *MakeMintCh) |
  rl!(`rho:rchain:authKey`, *AuthKeyCh) |
  rl!(`rho:lang:either`, *EitherCh) |
  rl!(`rho:lang:treeHashMap`, *TreeHashMapCh) |
  rl!(`rho:rchain:revVault`, *RevVaultCh) |
  for (@(_, MakeMint) <- MakeMintCh;
       @(_, AuthKey)  <- AuthKeyCh;
       @(_, Either)   <- EitherCh;
       @(_, RevVault) <- RevVaultCh; 
       TreeHashMap    <- TreeHashMapCh) {
    new mintCh, revMapStore, bulletMapStore, initVault, unf, authKeyCh, revHouseAddrCh in {
      // generate revHouse for holding deposited REV 
      RevAddress!("fromUnforgeable", *unf, *revHouseAddrCh) |
      @RevVault!("unforgeableAuthKey", *unf, *authKeyCh) |
      for (@revHouseVaultAuthKey <- authKeyCh;  @revHouseAddr <- revHouseAddrCh) {
        new revHouseVaultCh, _depositList in {
          @RevVault!("findOrCreate", revHouseAddr, *revHouseVaultCh) |
          deployId!(["revHouseAddr : ",revHouseAddr])|
          // mapstore for depositing REV
          TreeHashMap!("init", 2, *revMapStore) |
          // mapstore for bullet token
          TreeHashMap!("init", 2, *bulletMapStore)| 
          for (@(true, revHouseVault) <- revHouseVaultCh; @revMap <- revMapStore; @bulletMap <- bulletMapStore) {
            @MakeMint!(*mintCh) |
            for (mint <- mintCh) {
              contract initVault(name, @address, @initialAmount) = {
                new purseCh in {
                  mint!("makePurse", initialAmount, *purseCh) |
                  for (purse <- purseCh) {
                    _newVault!(*name, address, *purse)  
                  }
                }
              } |
              contract BulletVault(@"test",res) = {
                res!("test success")
              }
              |
              contract BulletVault(@"deployerAuthKey", deployerId, ret) = {
                new DeployerIdOps(`rho:rchain:deployerId:ops`),
                    revAddrCh, deployerPubKeyBytesCh
                in {
                  DeployerIdOps!("pubKeyBytes", *deployerId, *deployerPubKeyBytesCh) |
                  for (@deployerPubKeyBytes <- deployerPubKeyBytesCh) {
                    RevAddress!("fromPublicKey", deployerPubKeyBytes, *revAddrCh) |
                    for (@deployerRevAddress <- revAddrCh) {
                      @AuthKey!("make", (*_bulletVault, deployerRevAddress), *ret)
                    }
                  }
                }
              } |
              contract BulletVault(@"unforgeableAuthKey", unf, ret) = {
                new revAddrCh in {
                  RevAddress!("fromUnforgeable", *unf, *revAddrCh) |
                  for (@unfRevAddress <- revAddrCh) {
                    @AuthKey!("make", (*_bulletVault, unfRevAddress), *ret)
                  }
                }
              } |
              contract BulletVault(@"findOrCreate", @revAddress, retCh) = {
                new revAddressValidCh, revAddressValidEitherCh in {
                  RevAddress!("validate", revAddress, *revAddressValidCh) |
                  @Either!("fromNillableError <-", *revAddressValidCh, *revAddressValidEitherCh) |
                  for (@revAddressEither <- revAddressValidEitherCh) {
                    match revAddressEither {
                      (false, _) => {
                        retCh!(revAddressEither)
                      }
                      _ => {
                        new createVault, vaultCh, getVaultCh in {
                          TreeHashMap!("get", bulletMap, revAddress, *getVaultCh) |
                          for (@vault <- getVaultCh) {
                            if (vault != Nil) {
                              retCh!((true, vault))
                            } else {
                              _create!(revAddress, *createVault, *vaultCh) |
                              for (vaultRetCh <- createVault) {
                                _makeVault!(revAddress, 0, *vaultRetCh) |
                                for (@eitherVault <- vaultCh) {
                                  retCh!(eitherVault)
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              } |

              contract BulletVault(@"deposit", @amount, @rate, retCh) = {
                new DeployerIdOps(`rho:rchain:deployerId:ops`),
                    revAddrCh, deployerPubKeyBytesCh, deployerId(`rho:rchain:deployerId`)  
                in {
                  DeployerIdOps!("pubKeyBytes", *deployerId, *deployerPubKeyBytesCh) |
                  for (@deployerPubKeyBytes <- deployerPubKeyBytesCh) {
                    RevAddress!("fromPublicKey", deployerPubKeyBytes, *revAddrCh) |
                    for (@deployerRevAddress <- revAddrCh) {
                      new vaultCh, revVaultkeyCh in {
                        @RevVault!("findOrCreate", deployerRevAddress, *vaultCh) |
                        @RevVault!("deployerAuthKey", *deployerId, *revVaultkeyCh) |
                        for (@(true, vault) <- vaultCh; key <- revVaultkeyCh) {
                          // TODO: if the amount is below 10 REV, won't trigger.
                          new resultCh, ackCh, blockData(`rho:block:data`), tCh in {
                            @vault!("transfer", revHouseAddr, amount, *key, *resultCh) |
                            blockData!(*tCh) |
                            for (@result <- resultCh; @_, @t, @_ <- tCh) {
                              // TODO: If transfer failed,...
                              _depositList!("deposit", deployerRevAddress, {"timestamp":t,"amount":amount}, *ackCh)|
                              // send Bullet
                              new createVault, bulletVaultCh, balanceCh, vaultCh, vaultCh, getVaultCh in {
                                TreeHashMap!("get", bulletMap, deployerRevAddress, *getVaultCh) |
                                for (@vault <- getVaultCh) {
                                  if (vault != Nil) {
                                    @vault!("balance", *balanceCh)| 
                                    for (@balance <- balanceCh) {
                                      _create!(deployerRevAddress, *createVault, *bulletVaultCh) |
                                      for (vaultRetCh <- createVault) {
                                        _makeVault!(deployerRevAddress, amount / rate + balance, *vaultRetCh) |
                                        for (@eitherVault <- bulletVaultCh) {
                                          retCh!(eitherVault)
                                        }
                                      }
                                    }      
                                  } else {
                                    _create!(deployerRevAddress, *createVault, *bulletVaultCh) |
                                    for (vaultRetCh <- createVault) {
                                      _makeVault!(deployerRevAddress, amount / rate, *vaultRetCh) |
                                      for (@eitherVault <- bulletVaultCh) {
                                        retCh!(eitherVault)
                                      }
                                    }  
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  } 
                }       
              } |

              // contract BulletVault(@"withdraw", retCh) = {
              //   new DeployerIdOps(`rho:rchain:deployerId:ops`),
              //       revAddrCh, deployerPubKeyBytesCh, RevVaultCh, deployerId(`rho:rchain:deployerId`), getBalanceCh  
              //   in {
              //     DeployerIdOps!("pubKeyBytes", *deployerId, *deployerPubKeyBytesCh) |
              //     for (@deployerPubKeyBytes <- deployerPubKeyBytesCh) {
              //       RevAddress!("fromPublicKey", deployerPubKeyBytes, *revAddrCh) |
              //       for (@deployerRevAddress <- revAddrCh) {                         
              //         _depositList!("withdraw", deployerRevAddress, *retCh)
              //       }        
              //     }
              //   } 
              // } |  

              contract _depositList(@"deposit", @deployerRevAddress, @item, ackCh) = {
                new listCh in {
                  TreeHashMap!("get", revMap, deployerRevAddress, *listCh) |
                  for (@list <- listCh) {
                    if(list == Nil) {
                      TreeHashMap!("set", revMap, deployerRevAddress, [item], *ackCh) 
                    }else{
                      TreeHashMap!("set", revMap, deployerRevAddress, list ++ [item], *ackCh) 
                    }

                  }                
                }  
              } |

              // contract _depositList(@"withdraw", @deployerRevAddress, retCh) = {
              //   new blockData(`rho:block:data`), tCh, _remove, liCh, ret in {
              //     blockData!(*tCh) |
              //     TreeHashMap!("get", revMap, deployerRevAddress, *liCh) |
              //     for (@_, @t, @_ <- tCh; @li <- liCh) {
              //       if (li == [] or li == Nil) {
              //         deployId!("No record found!")
              //       } else{
              //         _remove!(t, li, *ret)
              //         |deployId!(["list: ", li])
              //       }
              //     }|
              //     contract _remove (newTimeStamp, items, ret) = {
              //       new resultCh, ack, removeAck in {
              //         if(*items != []){
              //           if (*items.nth(0).get("timestamp") < (*newTimeStamp - 200000)) {
              //             @revHouseVault!("transfer", deployerRevAddress, *items.nth(0).get("amount"), revHouseVaultAuthKey, *resultCh) |
              //             for (@res <- resultCh) {
              //               TreeHashMap!("set", revMap, deployerRevAddress, *items.slice(1,*items.length()), *ack) |
              //               for (@ackn <- ack) {
              //                 _remove!( *newTimeStamp, *items.slice(1,*items.length()), *removeAck)|
              //                 ret!(true)
              //                 |
              //                 new re1 in {
              //                   TreeHashMap!("get", revMap, deployerRevAddress, *re1) |
              //                   for (@r <- re1) {
              //                     deployId!(["The removing result: ", r])
              //                   }
              //                 }  
              //               }
              //             }
              //           }else{
              //             ret!(true)|
              //             retCh!(true)|
              //             new re in {
              //               TreeHashMap!("get", revMap, deployerRevAddress, *re) |
              //               for (@lis <- re) {
              //                   deployId!(["Final result:", lis])
              //                 }
              //             }    
              //           } 
              //         }                      
              //       }       
              //     }  
              //   }
              // } |  
              contract _create(@revAddress, constructor, retCh) = {
                // The vault was not found, create a new one and set it in the bulletMap.
                new resCh, ackCh in {
                  constructor!(*resCh) |
                  for (@eitherVault <- resCh) {
                    match eitherVault {
                      (true, vault) => {
                        TreeHashMap!("set", bulletMap, revAddress, vault, *ackCh) |
                        for (_ <- ackCh) {
                          retCh!(eitherVault)
                        }
                      }
                      (false, _)    => {
                        retCh!(eitherVault)
                      }
                    }
                  }
                }
              } |
              contract _makeVault(@ownerRevAddress, @initialAmount, ret) = {
                new revAddrCh, eitherRevAddrCh, purseCh, eitherPurseCh, mkVault in {
                  @Either!("fromNillable", ownerRevAddress, "Required `revAddress` parameter was Nil", *eitherRevAddrCh) |
                  mint!("makePurse", initialAmount, *purseCh) |
                  @Either!("fromNillable <-", *purseCh, "Couldn't create purse", *eitherPurseCh) |
                  @Either!("map2 <-", *eitherRevAddrCh, *eitherPurseCh,
                    for (@addr, purse, r <- mkVault) {
                      new bulletVault in {
                        _newVault!(*bulletVault, addr, *purse) |
                        r!(bundle+{*bulletVault})
                      }
                    },
                    *ret
                  )
                }
              } |
              contract _newVault(bulletVault, @ownRevAddress, purse) = {
                new logStore in {
                  logStore!(Nil) |
                  contract bulletVault(@"balance", ret) = {
                    purse!("getBalance", *ret)
                  } |
                  contract bulletVault(@"transfer", @revAddress, @amount, authKey, ret) = {
                    new ret2 in {
                      _transferTemplate!(ownRevAddress, *purse, revAddress, amount, *authKey, *ret2) |
                      for (@result <- ret2) {
                        ret!(result) |
                        for (logCh <<- logStore) {
                          if (Nil != *logCh) {
                            new bd(`rho:block:data`), bdCh in {
                              bd!(*bdCh) |
                              for (@blockNumber, @timestamp, @sender <- bdCh) {
                                logCh!(["transfer", revAddress, amount, result, blockNumber, timestamp, sender])
                              }
                            }
                          }
                        }
                      }
                    }
                  } |
                  contract bulletVault(@"setLog", logCh, authKey, ret) = {
                    new authKeyValidCh in {
                      @AuthKey!("check", *authKey, (*_bulletVault, ownRevAddress), *authKeyValidCh) |
                      for (@result <- authKeyValidCh) {
                        if (result) {
                          new ack in {
                            for (_ <- logStore) {
                              logStore!(*logCh) |
                              purse!("setLog", *logCh, *ack) |
                              for (_ <- ack) {
                                ret!(true)
                              }
                            }
                          }
                        } else {
                          ret!(false)
                        }
                      }
                    }
                  } |
                  contract @{ownRevAddress | bundle0{*_bulletVault}}(@"_deposit", depositPurse, retCh) = {
                    _depositTemplate!(*purse, *depositPurse, *retCh)
                  }
                }
              } |
              contract _transferTemplate(@ownRevAddress, purse, @revAddress, @amount, authKey, ret) = {
                new revAddressValid, revAddressValidEither, amountNonNegative,
                    authKeyValidCh, authKeyValidEitherCh,
                    parametersOkCh, parametersAndAuthOkCh,
                    split, eitherPurseCh, doDeposit
                in {
                  RevAddress!("validate", revAddress, *revAddressValid) |
                  @Either!("fromNillableError <-", *revAddressValid, *revAddressValidEither) |
                  @Either!("fromBoolean", amount >= 0, "Amount must be non-negative", *amountNonNegative) |
                  @AuthKey!("check", *authKey, (*_bulletVault, ownRevAddress), *authKeyValidCh) |
                  @Either!("fromBoolean <-", *authKeyValidCh, "Invalid AuthKey", *authKeyValidEitherCh) |
                  @Either!("productR <-", *revAddressValidEither, *amountNonNegative, *parametersOkCh) |
                  @Either!("productR <-", *parametersOkCh, *authKeyValidEitherCh, *parametersAndAuthOkCh) |
                  @Either!("flatMap <-", *parametersAndAuthOkCh, *split, *eitherPurseCh) |
                  for (_, retCh <- split) {
                    new amountPurseCh in {
                      purse!("split", amount, *amountPurseCh) |
                      @Either!("fromSingletonList <-", *amountPurseCh, "Insufficient funds", *retCh)
                    }
                  } |
                  @Either!("flatMap <-", *eitherPurseCh, *doDeposit, *ret) |
                  for (@p, retCh <- doDeposit) {
                    @{revAddress | bundle0{*_bulletVault}}!("_deposit", p, *retCh)
                  }
                }
              } |
              contract _depositTemplate(toPurse, fromPurse, retCh) = {
                new amountCh, depositSuccessCh in {
                  fromPurse!("getBalance", *amountCh) |
                  for (@amount <- amountCh) {
                    toPurse!("deposit", amount, *fromPurse, *depositSuccessCh) |
                    @Either!("fromBoolean <-", *depositSuccessCh, "BUG FOUND: purse deposit failed", *retCh)
                  }
                }
              } 
              |
              insertArbitrary!(bundle+{*BulletVault}, *uriOut) |
              for(@uri <- uriOut) {
                stdout!("Bullet here:")|
                stdout!(uri)|
                deployId!(uri)// |
              }
            }
          }
        }
      }
    }
  }
}      , Sig: 304502210085760e2f8b...520b3a38b6ac4369240d, SigAlgorithm: secp256k1, ValidAfterBlockNumber: -1
2023-11-19 03:51:21,722 [DEBUG] [c-nio-worker-ELG-3-1] [io.perfmark.PerfMark         ]- Error during PerfMark.<clinit>
java.lang.ClassNotFoundException: io.perfmark.impl.SecretPerfMarkImpl$PerfMarkImpl
	at java.base/jdk.internal.loader.BuiltinClassLoader.loadClass(BuiltinClassLoader.java:581)
	at java.base/jdk.internal.loader.ClassLoaders$AppClassLoader.loadClass(ClassLoaders.java:178)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:527)
	at java.base/java.lang.Class.forName0(Native Method)
	at java.base/java.lang.Class.forName(Class.java:315)
	at io.perfmark.PerfMark.<clinit>(PerfMark.java:36)
	at io.grpc.netty.NettyServerStream$TransportState.<init>(NettyServerStream.java:225)
	at io.grpc.netty.NettyServerHandler.onHeadersRead(NettyServerHandler.java:439)
	at io.grpc.netty.NettyServerHandler.access$900(NettyServerHandler.java:101)
	at io.grpc.netty.NettyServerHandler$FrameListener.onHeadersRead(NettyServerHandler.java:813)
	at io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$FrameReadListener.onHeadersRead(DefaultHttp2ConnectionDecoder.java:373)
	at io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$FrameReadListener.onHeadersRead(DefaultHttp2ConnectionDecoder.java:321)
	at io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$PrefaceFrameListener.onHeadersRead(DefaultHttp2ConnectionDecoder.java:665)
	at io.netty.handler.codec.http2.Http2InboundFrameLogger$1.onHeadersRead(Http2InboundFrameLogger.java:56)
	at io.netty.handler.codec.http2.DefaultHttp2FrameReader$2.processFragment(DefaultHttp2FrameReader.java:483)
	at io.netty.handler.codec.http2.DefaultHttp2FrameReader.readHeadersFrame(DefaultHttp2FrameReader.java:491)
	at io.netty.handler.codec.http2.DefaultHttp2FrameReader.processPayloadState(DefaultHttp2FrameReader.java:254)
	at io.netty.handler.codec.http2.DefaultHttp2FrameReader.readFrame(DefaultHttp2FrameReader.java:160)
	at io.netty.handler.codec.http2.Http2InboundFrameLogger.readFrame(Http2InboundFrameLogger.java:41)
	at io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder.decodeFrame(DefaultHttp2ConnectionDecoder.java:174)
	at io.netty.handler.codec.http2.Http2ConnectionHandler$FrameDecoder.decode(Http2ConnectionHandler.java:378)
	at io.netty.handler.codec.http2.Http2ConnectionHandler$PrefaceDecoder.decode(Http2ConnectionHandler.java:242)
	at io.netty.handler.codec.http2.Http2ConnectionHandler.decode(Http2ConnectionHandler.java:438)
	at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:498)
	at io.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:437)
	at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:276)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357)
	at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1410)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)
	at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:919)
	at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:163)
	at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:714)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:650)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:576)
	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:493)
	at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:989)
	at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)
	at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
	at java.base/java.lang.Thread.run(Thread.java:829)
2023-11-19 03:51:21,749 [INFO ] [node-runner-25      ] [c.r.n.i.ProposerInstance$    ]- Propose started
2023-11-19 03:51:21,752 [DEBUG] [node-runner-18      ] [c.rchain.casper.api.BlockAPI$]- Failure: another propose is in progress
2023-11-19 03:51:22,478 [INFO ] [node-runner-23      ] [c.r.c.b.proposer.Proposer    ]- getCasperSnapshot [724.13269 ms]
2023-11-19 03:51:22,487 [INFO ] [node-runner-18      ] [alizedHeightConstraintChecker]- Latest message is 0 blocks ahead of the last finalized block
2023-11-19 03:51:22,497 [INFO ] [node-runner-27      ] [c.r.c.b.p.BlockCreator$      ]- Creating block #1 (seqNum 1)
2023-11-19 03:51:22,575 [INFO ] [node-runner-29      ] [c.r.casper.rholang.RuntimeOps]- PreCharging 04be064356846e36e485408df50b877dd99ba406d87208add4c92b3c7d4e4c663c2fbc6a1e6534c7e5c0aec00b26486fad1daf20079423b7c8ebffbbdff3682b58 for 100000000
2023-11-19 03:51:24,569 [DEBUG] [node-runner-28      ] [coop.rchain.rholang.stdout   ]- "NEC here:"
2023-11-19 03:51:24,569 [DEBUG] [node-runner-27      ] [coop.rchain.rholang.stdout   ]- `rho:id:zogs6iegbqxrstnak1x3i6mwysjp97iusq7pnnzkpeuthiwx4hmzjy`
2023-11-19 03:51:24,574 [INFO ] [node-runner-27      ] [c.r.casper.rholang.RuntimeOps]- Refunding 04be064356846e36e485408df50b877dd99ba406d87208add4c92b3c7d4e4c663c2fbc6a1e6534c7e5c0aec00b26486fad1daf20079423b7c8ebffbbdff3682b58 with 99425132
2023-11-19 03:51:24,973 [INFO ] [node-runner-29      ] [c.r.casper.rholang.RuntimeOps]- PreCharging 04be064356846e36e485408df50b877dd99ba406d87208add4c92b3c7d4e4c663c2fbc6a1e6534c7e5c0aec00b26486fad1daf20079423b7c8ebffbbdff3682b58 for 100000000
2023-11-19 03:51:26,532 [DEBUG] [node-runner-27      ] [coop.rchain.rholang.stdout   ]- `rho:id:ixgdkbndz36r8bzka3yb58iw897sjumu5q3gygf7o8gf6wbxhb69zr`
2023-11-19 03:51:26,532 [DEBUG] [node-runner-26      ] [coop.rchain.rholang.stdout   ]- "Bullet here:"
2023-11-19 03:51:26,537 [INFO ] [node-runner-18      ] [c.r.casper.rholang.RuntimeOps]- Refunding 04be064356846e36e485408df50b877dd99ba406d87208add4c92b3c7d4e4c663c2fbc6a1e6534c7e5c0aec00b26486fad1daf20079423b7c8ebffbbdff3682b58 with 99420062
2023-11-19 03:51:27,808 [INFO ] [node-runner-18      ] [c.r.c.b.p.BlockCreator$      ]- Block created: #1 (9f231fbed5...) (2d) [5.311993485 sec]
2023-11-19 03:51:27,817 [INFO ] [node-runner-18      ] [c.r.c.MultiParentCasperImpl  ]- Validating block #1 (9f231fbed5...).
2023-11-19 03:51:27,901 [INFO ] [node-runner-18      ] [c.r.c.u.r.InterpreterUtil$   ]- Computed parents post state for Block #1 (9f231fbed5...) -- Sender ID 042e13eadc... -- M Parent Hash 3189b5db12... -- Contents 04bf0c7086...-- Shard ID root.
2023-11-19 03:51:29,777 [DEBUG] [node-runner-28      ] [coop.rchain.rholang.stdout   ]- "NEC here:"
2023-11-19 03:51:29,778 [DEBUG] [node-runner-26      ] [coop.rchain.rholang.stdout   ]- `rho:id:zogs6iegbqxrstnak1x3i6mwysjp97iusq7pnnzkpeuthiwx4hmzjy`
2023-11-19 03:51:31,729 [DEBUG] [node-runner-25      ] [coop.rchain.rholang.stdout   ]- "Bullet here:"
2023-11-19 03:51:31,730 [DEBUG] [node-runner-29      ] [coop.rchain.rholang.stdout   ]- `rho:id:ixgdkbndz36r8bzka3yb58iw897sjumu5q3gygf7o8gf6wbxhb69zr`
2023-11-19 03:51:32,625 [INFO ] [node-runner-24      ] [c.r.c.EquivocationDetector$  ]- Calculate checkNeglectedEquivocationsWithUpdate
2023-11-19 03:51:32,631 [INFO ] [node-runner-24      ] [c.r.c.EquivocationDetector$  ]- Calculate checkEquivocations.
2023-11-19 03:51:32,634 [INFO ] [node-runner-24      ] [c.r.c.MultiParentCasperImpl  ]- Block replayed: #1 (9f231fbed5...) (2d) (Valid) [4.814632138 sec]
2023-11-19 03:51:33,487 [INFO ] [node-runner-27      ] [c.r.c.MultiParentCasperImpl  ]- Removed 0 deploys from deploy history as we finalized block [3189b5db12...].
2023-11-19 03:51:33,504 [INFO ] [node-runner-27      ] [.r.c.e.BlockRetriever$$anon$1]- Block 9f231fbed5... is not in RequestedBlocks. Adding and marking recieved.
2023-11-19 03:51:33,510 [INFO ] [node-runner-27      ] [c.r.c.util.comm.CommUtilOps  ]- Sent hash 9f231fbed5... to peers
2023-11-19 03:51:33,520 [INFO ] [node-runner-24      ] [c.rchain.casper.api.BlockAPI$]- Success! Block 9f231fbed574bf447930b1f2fbd9f345e6da3a2b9f44508daade4cfb3391320c created and added.
2023-11-19 03:51:33,523 [INFO ] [node-runner-27      ] [c.r.n.i.ProposerInstance$    ]- Propose finished: ProposeSuccess(Valid) Block #1 (9f231fbed5...) created and added.
2023-11-19 03:51:33,528 [INFO ] [node-runner-24      ] [c.r.n.i.ProposerInstance$    ]- Propose started
2023-11-19 03:51:33,802 [INFO ] [node-runner-24      ] [c.r.c.b.proposer.Proposer    ]- getCasperSnapshot [274.364803 ms]
2023-11-19 03:51:33,805 [INFO ] [node-runner-18      ] [alizedHeightConstraintChecker]- Latest message is 1 blocks ahead of the last finalized block
2023-11-19 03:51:34,057 [INFO ] [node-runner-26      ] [.c.SynchronyConstraintChecker]- Seen 0 senders with weight 0 out of total 100002000000 (0.0 out of 0.0 needed)
2023-11-19 03:51:34,059 [INFO ] [node-runner-18      ] [c.r.c.b.p.BlockCreator$      ]- Creating block #2 (seqNum 2)
2023-11-19 03:51:34,062 [INFO ] [node-runner-18      ] [c.r.n.i.ProposerInstance$    ]- Propose failed: NoNewDeploys
2023-11-19 03:51:47,797 [DEBUG] [node-runner-24      ] [c.r.c.MultiParentCasperImpl  ]- Requesting CasperBuffer pendant hashes, 0 items.
2023-11-19 03:51:47,797 [DEBUG] [node-runner-24      ] [.r.c.e.BlockRetriever$$anon$1]- Running BlockRetriever maintenance (1 items unexpired).
2023-11-19 03:52:17,814 [DEBUG] [node-runner-25      ] [c.r.c.MultiParentCasperImpl  ]- Requesting CasperBuffer pendant hashes, 0 items.
2023-11-19 03:52:17,817 [DEBUG] [node-runner-25      ] [.r.c.e.BlockRetriever$$anon$1]- Running BlockRetriever maintenance (1 items unexpired).
2023-11-19 03:52:47,819 [DEBUG] [node-runner-29      ] [c.r.c.MultiParentCasperImpl  ]- Requesting CasperBuffer pendant hashes, 0 items.
2023-11-19 03:52:47,820 [DEBUG] [node-runner-29      ] [.r.c.e.BlockRetriever$$anon$1]- Running BlockRetriever maintenance (1 items unexpired).
2023-11-19 03:53:12,329 [DEBUG] [node-runner-28      ] [c.r.c.safety.CliqueOracle$   ]- Calculating fault tolerance for 9f231fbed574bf447930b1f2fbd9f345e6da3a2b9f44508daade4cfb3391320c.
2023-11-19 03:53:12,394 [INFO ] [node-runner-25      ] [c.r.c.MultiParentCasperImpl  ]- Received DeployData #1700365992275 -- new userCh, print(`rho:io:stdout`), ret in {
    contract @{"rl_factory"}(checkBalance, transfer, checkBulletBalance, depositForBullet, checkNECBalance, depositForNEC) = {
        contract checkBalance(addr, ret) = {
            new rl(`rho:registry:lookup`), RevVaultCh, vaultCh, balanceCh in {
                rl!(`rho:rchain:revVault`, *RevVaultCh) |
                for (@(_, RevVault) <- RevVaultCh) {
                    match *addr {
                        revAddress => {
                            print!(("Accessing vault at RevAddress", revAddress)) |
                            @RevVault!("findOrCreate", revAddress, *vaultCh) |
                            for (@(true, vault) <- vaultCh) {
                                print!("Obtained vault, checking balance") |
                                @vault!("balance", *balanceCh) |
                                for (@balance <- balanceCh) {
                                    ret!(balance)
                                }
                            }
                        }
                    }
                }
            }
        }
        |
        contract transfer(from, to, amount) = {
            new rl(`rho:registry:lookup`), RevVaultCh in {
                rl!(`rho:rchain:revVault`, *RevVaultCh) |
                for (@(_, RevVault) <- RevVaultCh) {
                    match (
                        *from,
                        *to,
                        *amount
                    ) {
                        (from, to, amount) => {
                            new vaultCh, targetVaultCh, revVaultkeyCh, deployerId(`rho:rchain:deployerId`) in {
                                @RevVault!("findOrCreate", from, *vaultCh) |
                                @RevVault!("findOrCreate", to, *targetVaultCh) |
                                @RevVault!("deployerAuthKey", *deployerId, *revVaultkeyCh) |
                                for (@(true, vault) <- vaultCh ; key <- revVaultkeyCh ; @(true, _) <- targetVaultCh) {
                                    print!(("Beginning transfer of ", amount, "REV from", from, "to", to)) |
                                    new resultCh in {
                                        @vault!("transfer", to, amount, *key, *resultCh) |
                                        for (@result <- resultCh) {
                                            print!(("Finished transfer of ", amount, "REV to", to, "result was:", result))
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        |
        contract checkBulletBalance(addr, ret) = {
            new rl(`rho:registry:lookup`), BulletVaultCh, vaultCh, balanceCh, res in {
                rl!(`rho:id:ixgdkbndz36r8bzka3yb58iw897sjumu5q3gygf7o8gf6wbxhb69zr`, *BulletVaultCh) |
                for (@BulletVault <- BulletVaultCh) {
                    match *addr {
                        revAddress => {
                            print!(("Accessing BulletVault at RevAddress", revAddress)) |
                            @BulletVault!("findOrCreate", revAddress, *vaultCh) |
                            // @BulletVault!("test", *res)|
                            // @"BulletVault"!("findOrCreate", *addr, *vaultCh) |
                            for (@(true, vault) <- vaultCh) {
                                print!("Obtained vault, checking balance") |
                                @vault!("balance", *balanceCh) |
                                for (@balance <- balanceCh) {
                                    ret!(balance)
                                }
                            }
                        }
                    }
                }
            }
        }
        |
        contract depositForBullet(amount, rate) = {
            new rl(`rho:registry:lookup`), BulletVaultCh, retCh in {
                rl!(`rho:id:ixgdkbndz36r8bzka3yb58iw897sjumu5q3gygf7o8gf6wbxhb69zr`, *BulletVaultCh) |
                for (@BulletVault <- BulletVaultCh) {
                    match (*amount, *rate){
                        (amount, rate) => {
                            print!("start deposit")|
                            @BulletVault!("deposit", amount, rate, *retCh) |
                            for (@result <- retCh) {
                                print!(("Finished deposit, pay amount: ", amount))
                            }
                        }
                    }
                }
            }
        }
        |
        contract checkNECBalance(addr, ret) = {
            new rl(`rho:registry:lookup`), NecVaultCh, vaultCh, balanceCh, res in {
                rl!(`rho:id:zogs6iegbqxrstnak1x3i6mwysjp97iusq7pnnzkpeuthiwx4hmzjy`, *NecVaultCh) |
                for (@NecVault <- NecVaultCh) {
                    match *addr {
                        revAddress => {
                            print!(("Accessing NECVault at RevAddress", revAddress)) |
                            @NecVault!("findOrCreate", revAddress, *vaultCh) |
                            // @NecVault!("test", *res)|
                            // @"NecVault"!("findOrCreate", *addr, *vaultCh) |
                            for (@(true, vault) <- vaultCh) {
                                print!("Obtained vault, checking balance") |
                                @vault!("balance", *balanceCh) |
                                for (@balance <- balanceCh) {
                                    ret!(balance)
                                }
                            }
                        }
                    }
                }
            }
        }
        |
        contract depositForNEC(amount, rate) = {
            new rl(`rho:registry:lookup`), NecVaultCh, retCh in {
                rl!(`rho:id:zogs6iegbqxrstnak1x3i6mwysjp97iusq7pnnzkpeuthiwx4hmzjy`, *NecVaultCh) |
                for (@NecVault <- NecVaultCh) {
                    match (*amount, *rate){
                        (amount, rate) => {
                            print!("start deposit")|
                            @NecVault!("deposit", amount, rate, *retCh) |
                            for (@result <- retCh) {
                                print!(("Finished deposit, pay amount: ", amount))
                            }
                        }
                    }
                }
            }
        }
    }
}, Sig: 3045022100e859e1abea...eff1404398d6d0a5f58c, SigAlgorithm: secp256k1, ValidAfterBlockNumber: 1
2023-11-19 03:53:12,413 [INFO ] [node-runner-27      ] [c.r.n.i.ProposerInstance$    ]- Propose started
2023-11-19 03:53:12,636 [INFO ] [node-runner-28      ] [c.r.c.b.proposer.Proposer    ]- getCasperSnapshot [223.390562 ms]
2023-11-19 03:53:12,639 [INFO ] [node-runner-28      ] [alizedHeightConstraintChecker]- Latest message is 1 blocks ahead of the last finalized block
2023-11-19 03:53:12,840 [INFO ] [node-runner-29      ] [.c.SynchronyConstraintChecker]- Seen 0 senders with weight 0 out of total 100002000000 (0.0 out of 0.0 needed)
2023-11-19 03:53:12,842 [INFO ] [node-runner-29      ] [c.r.c.b.p.BlockCreator$      ]- Creating block #2 (seqNum 2)
2023-11-19 03:53:12,874 [INFO ] [node-runner-27      ] [c.r.casper.rholang.RuntimeOps]- PreCharging 04be064356846e36e485408df50b877dd99ba406d87208add4c92b3c7d4e4c663c2fbc6a1e6534c7e5c0aec00b26486fad1daf20079423b7c8ebffbbdff3682b58 for 100000000
2023-11-19 03:53:13,402 [INFO ] [node-runner-29      ] [c.r.casper.rholang.RuntimeOps]- Refunding 04be064356846e36e485408df50b877dd99ba406d87208add4c92b3c7d4e4c663c2fbc6a1e6534c7e5c0aec00b26486fad1daf20079423b7c8ebffbbdff3682b58 with 99981352
2023-11-19 03:53:14,313 [INFO ] [node-runner-27      ] [c.r.c.b.p.BlockCreator$      ]- Block created: #2 (e72cf4d436...) (1d) [1.470659839 sec]
2023-11-19 03:53:14,313 [INFO ] [node-runner-27      ] [c.r.c.MultiParentCasperImpl  ]- Validating block #2 (e72cf4d436...).
2023-11-19 03:53:14,351 [INFO ] [node-runner-27      ] [c.r.c.u.r.InterpreterUtil$   ]- Computed parents post state for Block #2 (e72cf4d436...) -- Sender ID 042e13eadc... -- M Parent Hash 9f231fbed5... -- Contents 0eb6edfa9b...-- Shard ID root.
2023-11-19 03:53:15,711 [INFO ] [node-runner-24      ] [c.r.c.EquivocationDetector$  ]- Calculate checkNeglectedEquivocationsWithUpdate
2023-11-19 03:53:15,711 [INFO ] [node-runner-24      ] [c.r.c.EquivocationDetector$  ]- Calculate checkEquivocations.
2023-11-19 03:53:15,712 [INFO ] [node-runner-24      ] [c.r.c.MultiParentCasperImpl  ]- Block replayed: #2 (e72cf4d436...) (1d) (Valid) [1.398211468 sec]
2023-11-19 03:53:15,837 [INFO ] [node-runner-28      ] [c.r.c.MultiParentCasperImpl  ]- Removed 0 deploys from deploy history as we finalized block [3189b5db12...].
2023-11-19 03:53:15,844 [INFO ] [node-runner-28      ] [.r.c.e.BlockRetriever$$anon$1]- Block e72cf4d436... is not in RequestedBlocks. Adding and marking recieved.
2023-11-19 03:53:15,845 [INFO ] [node-runner-28      ] [c.r.c.util.comm.CommUtilOps  ]- Sent hash e72cf4d436... to peers
2023-11-19 03:53:15,847 [INFO ] [node-runner-29      ] [c.rchain.casper.api.BlockAPI$]- Success! Block e72cf4d436d8390a20ef4726d03f68438ea0bf7654c95e62d59ef827a1dd3aab created and added.
2023-11-19 03:53:15,847 [INFO ] [node-runner-28      ] [c.r.n.i.ProposerInstance$    ]- Propose finished: ProposeSuccess(Valid) Block #2 (e72cf4d436...) created and added.
2023-11-19 03:53:17,821 [DEBUG] [node-runner-18      ] [c.r.c.MultiParentCasperImpl  ]- Requesting CasperBuffer pendant hashes, 0 items.
2023-11-19 03:53:17,821 [DEBUG] [node-runner-18      ] [.r.c.e.BlockRetriever$$anon$1]- Running BlockRetriever maintenance (2 items unexpired).
