2023-11-16 13:13:43,905 [INFO ] [main                ] [coop.rchain.node.Main$       ]- RChain Node 0.13.0-alpha3 (c766347c6df06d813f802ae9e4ca1186647cf070)
2023-11-16 13:13:43,908 [INFO ] [main                ] [coop.rchain.node.Main$       ]- Starting with profile default
2023-11-16 13:13:43,908 [INFO ] [main                ] [coop.rchain.node.Main$       ]- Using configuration file: /home/nardack/Desktop/DEX/Server/config.conf
2023-11-16 13:13:43,908 [INFO ] [main                ] [coop.rchain.node.Main$       ]- Running on network: testnet
2023-11-16 13:13:44,081 [INFO ] [main                ] [c.r.node.NodeEnvironment$    ]- Using data dir: /home/nardack/Desktop/DEX/Server/rnode0
2023-11-16 13:13:44,085 [INFO ] [main                ] [t.GenerateCertificateIfAbsent]- No certificate found at path rnode0/node.certificate.pem
2023-11-16 13:13:44,085 [INFO ] [main                ] [t.GenerateCertificateIfAbsent]- Generating a X.509 certificate for the node
2023-11-16 13:13:44,087 [INFO ] [main                ] [t.GenerateCertificateIfAbsent]- Generating a PEM secret key for the node
2023-11-16 13:13:44,336 [DEBUG] [main                ] [jdk.event.security           ]- X509Certificate: Alg:SHA256withECDSA, Serial:92f24abfa24f2692, Subject:CN=7761cc790a9220f17c909d73944997d5c03447ed, Issuer:CN=7761cc790a9220f17c909d73944997d5c03447ed, Key type:EC, Length:256, Cert Id:953406764, Valid from:2023/11/16 下午9:13, Valid until:2024/11/15 下午9:13
2023-11-16 13:13:44,514 [DEBUG] [main                ] [c.r.s.LmdbStoreManagerImpl   ]- Creating LMDB environment: rnode0/dagstorage
2023-11-16 13:13:44,709 [DEBUG] [main                ] [c.r.s.LmdbStoreManagerImpl   ]- Creating LMDB database: last-finalized-block, env: rnode0/dagstorage
2023-11-16 13:13:44,732 [INFO ] [main                ] [c.r.b.dag.BlockMetadataStore$]- Building in-memory blockMetadataStore.
2023-11-16 13:13:44,734 [DEBUG] [main                ] [c.r.s.LmdbStoreManagerImpl   ]- Creating LMDB database: block-metadata, env: rnode0/dagstorage
2023-11-16 13:13:44,742 [INFO ] [main                ] [c.r.b.dag.BlockMetadataStore$]- Reading data from blockMetadataStore done.
2023-11-16 13:13:44,764 [INFO ] [main                ] [c.r.b.dag.BlockMetadataStore$]- Successfully built in-memory blockMetadataStore.
2023-11-16 13:13:44,774 [DEBUG] [main                ] [c.r.s.LmdbStoreManagerImpl   ]- Creating LMDB environment: rnode0/casperbuffer
2023-11-16 13:13:44,775 [DEBUG] [main                ] [c.r.s.LmdbStoreManagerImpl   ]- Creating LMDB database: parents-map, env: rnode0/casperbuffer
2023-11-16 13:13:44,858 [DEBUG] [main                ] [c.r.s.LmdbStoreManagerImpl   ]- Creating LMDB environment: rnode0/eval/history
2023-11-16 13:13:44,860 [DEBUG] [main                ] [c.r.s.LmdbStoreManagerImpl   ]- Creating LMDB database: eval-roots, env: rnode0/eval/history
2023-11-16 13:13:44,889 [DEBUG] [main                ] [c.r.s.LmdbStoreManagerImpl   ]- Creating LMDB database: eval-history, env: rnode0/eval/history
2023-11-16 13:13:46,157 [DEBUG] [main                ] [c.r.s.LmdbStoreManagerImpl   ]- Creating LMDB environment: rnode0/rspace/history
2023-11-16 13:13:46,158 [DEBUG] [main                ] [c.r.s.LmdbStoreManagerImpl   ]- Creating LMDB database: rspace-roots, env: rnode0/rspace/history
2023-11-16 13:13:46,163 [DEBUG] [main                ] [c.r.s.LmdbStoreManagerImpl   ]- Creating LMDB database: rspace-history, env: rnode0/rspace/history
2023-11-16 13:13:46,521 [DEBUG] [node-runner-18      ] [c.r.s.LmdbStoreManagerImpl   ]- Creating LMDB database: blocks-approved, env: rnode0/dagstorage
2023-11-16 13:13:46,527 [INFO ] [node-runner-18      ] [c.r.c.e.CasperLaunch$$anon$1 ]- Approved block not found, taking part in ceremony as ceremony master
2023-11-16 13:13:46,550 [INFO ] [node-runner-18      ] [c.r.casper.util.VaultParser$ ]- Parsing wallets file rnode0/genesis/wallets.txt.
2023-11-16 13:13:46,668 [INFO ] [node-runner-18      ] [c.r.casper.util.VaultParser$ ]- Wallet loaded: 1111Wbd8KLeWBVsxByF9iksJ4QRRjEF3nq1ScgAw7bMbtomxHsqqd,1000000000000000,0
2023-11-16 13:13:46,671 [INFO ] [node-runner-18      ] [c.r.casper.util.VaultParser$ ]- Wallet loaded: 1111235s1WgxZjTRi1McWXNtys53mhUSmXoRq72YMzGL6v12fkLFHv,100000000,0
2023-11-16 13:13:46,673 [INFO ] [node-runner-18      ] [c.r.casper.util.VaultParser$ ]- Wallet loaded: 11112Bqt2LBKM2k5UbS9twPzf7VzhCuNt8Tj1ncVQruA1hhMDJWpfB,1000,0
2023-11-16 13:13:46,695 [INFO ] [node-runner-18      ] [c.r.casper.util.BondsParser$ ]- Parsing bonds file rnode0/genesis/bonds.txt.
2023-11-16 13:13:46,707 [INFO ] [node-runner-18      ] [c.r.casper.util.BondsParser$ ]- Bond loaded 04be064356846e36e485408df50b877dd99ba406d87208add4c92b3c7d4e4c663c2fbc6a1e6534c7e5c0aec00b26486fad1daf20079423b7c8ebffbbdff3682b58 => 100000000000
2023-11-16 13:13:46,710 [INFO ] [node-runner-18      ] [c.r.casper.util.BondsParser$ ]- Bond loaded 042e13eadc97fb886eed6ba8fda1f1aa5d1cb653f1fcb765cf03c9cfdcba01aa79f367ec0dd86bf8a0508110aa97b66fdf7139fa8bbac86a8b9c1dac20e656574c => 1000000
2023-11-16 13:13:46,713 [INFO ] [node-runner-18      ] [c.r.casper.util.BondsParser$ ]- Bond loaded 049ab5d17cda550253f76425d33c69891a99a6d00d7b190767305e493ce5b35f823a1ec144c9242c1ceb5e915095dabaff30f6fea48c5dcb213c6fb7a87050f657 => 1000000
2023-11-16 13:13:46,717 [INFO ] [node-runner-18      ] [c.r.casper.util.BondsParser$ ]- Bond loaded 04d34d5f438e9db72725489b54e8012f856d9a26e3ab4dea6e5938bdf91b7d7952e6ebb263450315d71176d1718681fd9814c330cfac07e8b9b8d84e6c72dfdd78 => 1000000
2023-11-16 13:13:47,951 [DEBUG] [node-runner-23      ] [c.r.s.LmdbStoreManagerImpl   ]- Creating LMDB environment: rnode0/rspace/cold
2023-11-16 13:13:47,952 [DEBUG] [node-runner-23      ] [c.r.s.LmdbStoreManagerImpl   ]- Creating LMDB database: rspace-cold, env: rnode0/rspace/cold
2023-11-16 13:13:57,397 [DEBUG] [node-runner-24      ] [c.r.s.LmdbStoreManagerImpl   ]- Creating LMDB database: mergeable-channel-cache, env: rnode0/dagstorage
2023-11-16 13:13:57,728 [INFO ] [node-runner-24      ] [c.r.node.runtime.NodeRuntime ]- Starting stand-alone node.
2023-11-16 13:13:58,737 [INFO ] [node-runner-24      ] [c.r.n.r.ServersInstances$    ]- HTTP API server started at 192.168.59.133:40403
2023-11-16 13:13:58,749 [INFO ] [node-runner-24      ] [c.r.n.r.ServersInstances$    ]- Admin HTTP API server started at 192.168.59.133:40405
2023-11-16 13:13:58,832 [INFO ] [node-runner-25      ] [ocol$ApproveBlockProtocolImpl]- Starting execution of ApprovedBlockProtocol. Waiting for 0 approvals from genesis validators.
2023-11-16 13:13:58,834 [INFO ] [node-runner-25      ] [ocol$ApproveBlockProtocolImpl]- Self-approving genesis block.
2023-11-16 13:13:58,837 [DEBUG] [node-runner-26      ] [.r.c.e.BlockRetriever$$anon$1]- Running BlockRetriever maintenance (0 items unexpired).
2023-11-16 13:13:58,911 [INFO ] [node-runner-25      ] [ocol$ApproveBlockProtocolImpl]- Sending ApprovedBlock e1a8c224da... to peers...
2023-11-16 13:13:58,942 [INFO ] [node-runner-25      ] [ocol$ApproveBlockProtocolImpl]- Finished execution of ApprovedBlockProtocol
2023-11-16 13:13:59,009 [INFO ] [node-runner-23      ] [c.r.n.r.ServersInstances$    ]- Kademlia RPC server started at 192.168.59.133:40404
2023-11-16 13:13:59,009 [INFO ] [node-runner-37      ] [c.r.n.r.ServersInstances$    ]- External API server started at 192.168.59.133:40401
2023-11-16 13:13:59,009 [INFO ] [node-runner-18      ] [c.r.n.r.ServersInstances$    ]- Internal API server started at 192.168.59.133:40402
2023-11-16 13:13:59,023 [DEBUG] [node-runner-29      ] [jdk.event.security           ]- X509Certificate: Alg:SHA256withRSA, Serial:752bd03efd500194, Subject:CN=example.com, Issuer:CN=example.com, Key type:RSA, Length:2048, Cert Id:1467855822, Valid from:2018/4/7 上午6:06, Valid until:10000/1/1 上午7:59
2023-11-16 13:13:59,161 [INFO ] [node-runner-29      ] [c.r.n.r.ServersInstances$    ]- Listening for traffic on rnode://7761cc790a9220f17c909d73944997d5c03447ed@192.168.59.133?protocol=40400&discovery=40404.
2023-11-16 13:13:59,737 [DEBUG] [node-runner-29      ] [c.r.s.LmdbStoreManagerImpl   ]- Creating LMDB environment: rnode0/blockstorage
2023-11-16 13:13:59,738 [DEBUG] [node-runner-29      ] [c.r.s.LmdbStoreManagerImpl   ]- Creating LMDB database: blocks, env: rnode0/blockstorage
2023-11-16 13:13:59,749 [WARN ] [node-runner-29      ] [.b.d.BlockDagKeyValueStorage$]- Block Block #0 (e1a8c224da...) with empty parents (supposedly genesis) sender is empty.
2023-11-16 13:13:59,759 [DEBUG] [node-runner-29      ] [c.r.s.LmdbStoreManagerImpl   ]- Creating LMDB database: deploy-index, env: rnode0/dagstorage
2023-11-16 13:13:59,768 [DEBUG] [node-runner-29      ] [c.r.s.LmdbStoreManagerImpl   ]- Creating LMDB database: latest-messages, env: rnode0/dagstorage
2023-11-16 13:13:59,786 [DEBUG] [node-runner-29      ] [c.r.s.LmdbStoreManagerImpl   ]- Creating LMDB database: invalid-blocks, env: rnode0/dagstorage
2023-11-16 13:13:59,822 [INFO ] [node-runner-29      ] [c.r.casper.engine.Engine$    ]- Making a transition to Running state. Approved Block #0 (e1a8c224da...) with empty parents (supposedly genesis)
2023-11-16 13:13:59,845 [INFO ] [node-runner-29      ] [c.r.c.util.comm.CommUtilOps  ]- Requested fork tip from peers
2023-11-16 13:14:28,843 [DEBUG] [node-runner-25      ] [c.r.c.MultiParentCasperImpl  ]- Requesting CasperBuffer pendant hashes, 0 items.
2023-11-16 13:14:28,844 [DEBUG] [node-runner-25      ] [.r.c.e.BlockRetriever$$anon$1]- Running BlockRetriever maintenance (0 items unexpired).
2023-11-16 13:14:58,857 [DEBUG] [node-runner-18      ] [c.r.c.MultiParentCasperImpl  ]- Requesting CasperBuffer pendant hashes, 0 items.
2023-11-16 13:14:58,858 [DEBUG] [node-runner-18      ] [.r.c.e.BlockRetriever$$anon$1]- Running BlockRetriever maintenance (0 items unexpired).
2023-11-16 13:15:28,865 [DEBUG] [node-runner-37      ] [c.r.c.MultiParentCasperImpl  ]- Requesting CasperBuffer pendant hashes, 0 items.
2023-11-16 13:15:28,865 [DEBUG] [node-runner-37      ] [.r.c.e.BlockRetriever$$anon$1]- Running BlockRetriever maintenance (0 items unexpired).
2023-11-16 13:15:58,876 [DEBUG] [node-runner-25      ] [c.r.c.MultiParentCasperImpl  ]- Requesting CasperBuffer pendant hashes, 0 items.
2023-11-16 13:15:58,876 [DEBUG] [node-runner-25      ] [.r.c.e.BlockRetriever$$anon$1]- Running BlockRetriever maintenance (0 items unexpired).
2023-11-16 13:16:03,929 [DEBUG] [node-runner-29      ] [c.r.c.safety.CliqueOracle$   ]- Calculating fault tolerance for e1a8c224dabe7a45b7f2c2c40d9efd24ce7bdb98f4df1f326afa0b5e1d874391.
2023-11-16 13:16:03,929 [DEBUG] [node-runner-37      ] [c.r.c.safety.CliqueOracle$   ]- Calculating fault tolerance for e1a8c224dabe7a45b7f2c2c40d9efd24ce7bdb98f4df1f326afa0b5e1d874391.
2023-11-16 13:16:03,977 [DEBUG] [node-runner-23      ] [c.r.s.LmdbStoreManagerImpl   ]- Creating LMDB database: equivocation-tracker, env: rnode0/dagstorage
2023-11-16 13:16:04,262 [DEBUG] [node-runner-37      ] [c.r.s.LmdbStoreManagerImpl   ]- Creating LMDB environment: rnode0/deploystorage
2023-11-16 13:16:04,263 [DEBUG] [node-runner-37      ] [c.r.s.LmdbStoreManagerImpl   ]- Creating LMDB database: deploy_storage, env: rnode0/deploystorage
2023-11-16 13:16:04,266 [INFO ] [node-runner-37      ] [c.r.c.MultiParentCasperImpl  ]- Received DeployData #1700140563532 -- new
  NecVault, rs(`rho:registry:insertSigned:secp256k1`), uriOut,
  rl(`rho:registry:lookup`), RevAddress(`rho:rev:address`),
  insertArbitrary(`rho:registry:insertArbitrary`),
  stdout(`rho:io:stdout`), deployId(`rho:rchain:deployId`),
  MakeMintCh, AuthKeyCh, EitherCh, TreeHashMapCh, RevVaultCh, 
  _makeVault,
  _newVault,
  _create,
  _necVault,
  _transferTemplate,
  _depositTemplate
in {
  rl!(`rho:rchain:makeMint`, *MakeMintCh) |
  rl!(`rho:rchain:authKey`, *AuthKeyCh) |
  rl!(`rho:lang:either`, *EitherCh) |
  rl!(`rho:lang:treeHashMap`, *TreeHashMapCh) |
  rl!(`rho:rchain:revVault`, *RevVaultCh) |
  for (@(_, MakeMint) <- MakeMintCh;
       @(_, AuthKey)  <- AuthKeyCh;
       @(_, Either)   <- EitherCh;
       @(_, RevVault) <- RevVaultCh; 
       TreeHashMap    <- TreeHashMapCh) {
    new mintCh, revMapStore, necMapStore, initVault, unf, authKeyCh, revHouseAddrCh in {
      // generate revHouse for holding deposited REV 
      RevAddress!("fromUnforgeable", *unf, *revHouseAddrCh) |
      @RevVault!("unforgeableAuthKey", *unf, *authKeyCh) |
      for (@revHouseVaultAuthKey <- authKeyCh;  @revHouseAddr <- revHouseAddrCh) {
        new revHouseVaultCh, _depositList in {
          @RevVault!("findOrCreate", revHouseAddr, *revHouseVaultCh) |
          deployId!(["revHouseAddr : ",revHouseAddr])|
          // mapstore for depositing REV
          TreeHashMap!("init", 2, *revMapStore) |
          // mapstore for nec token
          TreeHashMap!("init", 2, *necMapStore)| 
          for (@(true, revHouseVault) <- revHouseVaultCh; @revMap <- revMapStore; @necMap <- necMapStore) {
            @MakeMint!(*mintCh) |
            for (mint <- mintCh) {
              contract initVault(name, @address, @initialAmount) = {
                new purseCh in {
                  mint!("makePurse", initialAmount, *purseCh) |
                  for (purse <- purseCh) {
                    _newVault!(*name, address, *purse)  
                  }
                }
              } |
              contract NecVault(@"test",res) = {
                res!("test success")
              }
              |
              contract NecVault(@"deployerAuthKey", deployerId, ret) = {
                new DeployerIdOps(`rho:rchain:deployerId:ops`),
                    revAddrCh, deployerPubKeyBytesCh
                in {
                  DeployerIdOps!("pubKeyBytes", *deployerId, *deployerPubKeyBytesCh) |
                  for (@deployerPubKeyBytes <- deployerPubKeyBytesCh) {
                    RevAddress!("fromPublicKey", deployerPubKeyBytes, *revAddrCh) |
                    for (@deployerRevAddress <- revAddrCh) {
                      @AuthKey!("make", (*_necVault, deployerRevAddress), *ret)
                    }
                  }
                }
              } |
              contract NecVault(@"unforgeableAuthKey", unf, ret) = {
                new revAddrCh in {
                  RevAddress!("fromUnforgeable", *unf, *revAddrCh) |
                  for (@unfRevAddress <- revAddrCh) {
                    @AuthKey!("make", (*_necVault, unfRevAddress), *ret)
                  }
                }
              } |
              contract NecVault(@"findOrCreate", @revAddress, retCh) = {
                new revAddressValidCh, revAddressValidEitherCh in {
                  RevAddress!("validate", revAddress, *revAddressValidCh) |
                  @Either!("fromNillableError <-", *revAddressValidCh, *revAddressValidEitherCh) |
                  for (@revAddressEither <- revAddressValidEitherCh) {
                    match revAddressEither {
                      (false, _) => {
                        retCh!(revAddressEither)
                      }
                      _ => {
                        new createVault, vaultCh, getVaultCh in {
                          TreeHashMap!("get", necMap, revAddress, *getVaultCh) |
                          for (@vault <- getVaultCh) {
                            if (vault != Nil) {
                              retCh!((true, vault))
                            } else {
                              _create!(revAddress, *createVault, *vaultCh) |
                              for (vaultRetCh <- createVault) {
                                _makeVault!(revAddress, 0, *vaultRetCh) |
                                for (@eitherVault <- vaultCh) {
                                  retCh!(eitherVault)
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              } |

              contract NecVault(@"deposit", @amount, retCh) = {
                new DeployerIdOps(`rho:rchain:deployerId:ops`),
                    revAddrCh, deployerPubKeyBytesCh, deployerId(`rho:rchain:deployerId`)  
                in {
                  DeployerIdOps!("pubKeyBytes", *deployerId, *deployerPubKeyBytesCh) |
                  for (@deployerPubKeyBytes <- deployerPubKeyBytesCh) {
                    RevAddress!("fromPublicKey", deployerPubKeyBytes, *revAddrCh) |
                    for (@deployerRevAddress <- revAddrCh) {
                      new vaultCh, revVaultkeyCh in {
                        @RevVault!("findOrCreate", deployerRevAddress, *vaultCh) |
                        @RevVault!("deployerAuthKey", *deployerId, *revVaultkeyCh) |
                        for (@(true, vault) <- vaultCh; key <- revVaultkeyCh) {
                          // TODO: if the amount is below 10 REV, won't trigger.
                          new resultCh, ackCh, blockData(`rho:block:data`), tCh in {
                            @vault!("transfer", revHouseAddr, amount, *key, *resultCh) |
                            blockData!(*tCh) |
                            for (@result <- resultCh; @_, @t, @_ <- tCh) {
                              // TODO: If transfer failed,...
                              _depositList!("deposit", deployerRevAddress, {"timestamp":t,"amount":amount}, *ackCh)|
                              // send NEC
                              new createVault, necVaultCh, balanceCh, vaultCh, vaultCh, getVaultCh in {
                                TreeHashMap!("get", necMap, deployerRevAddress, *getVaultCh) |
                                for (@vault <- getVaultCh) {
                                  if (vault != Nil) {
                                    @vault!("balance", *balanceCh)| 
                                    for (@balance <- balanceCh) {
                                      _create!(deployerRevAddress, *createVault, *necVaultCh) |
                                      for (vaultRetCh <- createVault) {
                                        _makeVault!(deployerRevAddress, amount / 100 + balance, *vaultRetCh) |
                                        for (@eitherVault <- necVaultCh) {
                                          retCh!(eitherVault)
                                        }
                                      }
                                    }      
                                  } else {
                                    _create!(deployerRevAddress, *createVault, *necVaultCh) |
                                    for (vaultRetCh <- createVault) {
                                      _makeVault!(deployerRevAddress, amount / 100, *vaultRetCh) |
                                      for (@eitherVault <- necVaultCh) {
                                        retCh!(eitherVault)
                                      }
                                    }  
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  } 
                }       
              } |

              contract NecVault(@"withdraw", retCh) = {
                new DeployerIdOps(`rho:rchain:deployerId:ops`),
                    revAddrCh, deployerPubKeyBytesCh, RevVaultCh, deployerId(`rho:rchain:deployerId`), getBalanceCh  
                in {
                  DeployerIdOps!("pubKeyBytes", *deployerId, *deployerPubKeyBytesCh) |
                  for (@deployerPubKeyBytes <- deployerPubKeyBytesCh) {
                    RevAddress!("fromPublicKey", deployerPubKeyBytes, *revAddrCh) |
                    for (@deployerRevAddress <- revAddrCh) {                         
                      _depositList!("withdraw", deployerRevAddress, *retCh)
                    }        
                  }
                } 
              } |  

              contract _depositList(@"deposit", @deployerRevAddress, @item, ackCh) = {
                new listCh in {
                  TreeHashMap!("get", revMap, deployerRevAddress, *listCh) |
                  for (@list <- listCh) {
                    if(list == Nil) {
                      TreeHashMap!("set", revMap, deployerRevAddress, [item], *ackCh) 
                    }else{
                      TreeHashMap!("set", revMap, deployerRevAddress, list ++ [item], *ackCh) 
                    }

                  }                
                }  
              } |

              contract _depositList(@"withdraw", @deployerRevAddress, retCh) = {
                new blockData(`rho:block:data`), tCh, _remove, liCh, ret in {
                  blockData!(*tCh) |
                  TreeHashMap!("get", revMap, deployerRevAddress, *liCh) |
                  for (@_, @t, @_ <- tCh; @li <- liCh) {
                    if (li == [] or li == Nil) {
                      deployId!("No record found!")
                    } else{
                      _remove!(t, li, *ret)
                      |deployId!(["list: ", li])
                    }
                  }|
                  contract _remove (newTimeStamp, items, ret) = {
                    new resultCh, ack, removeAck in {
                      if(*items != []){
                        if (*items.nth(0).get("timestamp") < (*newTimeStamp - 200000)) {
                          @revHouseVault!("transfer", deployerRevAddress, *items.nth(0).get("amount"), revHouseVaultAuthKey, *resultCh) |
                          for (@res <- resultCh) {
                            TreeHashMap!("set", revMap, deployerRevAddress, *items.slice(1,*items.length()), *ack) |
                            for (@ackn <- ack) {
                              _remove!( *newTimeStamp, *items.slice(1,*items.length()), *removeAck)|
                              ret!(true)
                              |
                              new re1 in {
                                TreeHashMap!("get", revMap, deployerRevAddress, *re1) |
                                for (@r <- re1) {
                                  deployId!(["The removing result: ", r])
                                }
                              }  
                            }
                          }
                        }else{
                          ret!(true)|
                          retCh!(true)|
                          new re in {
                            TreeHashMap!("get", revMap, deployerRevAddress, *re) |
                            for (@lis <- re) {
                                deployId!(["Final result:", lis])
                              }
                          }    
                        } 
                      }                      
                    }       
                  }  
                }
              } |  
              contract _create(@revAddress, constructor, retCh) = {
                // The vault was not found, create a new one and set it in the necMap.
                new resCh, ackCh in {
                  constructor!(*resCh) |
                  for (@eitherVault <- resCh) {
                    match eitherVault {
                      (true, vault) => {
                        TreeHashMap!("set", necMap, revAddress, vault, *ackCh) |
                        for (_ <- ackCh) {
                          retCh!(eitherVault)
                        }
                      }
                      (false, _)    => {
                        retCh!(eitherVault)
                      }
                    }
                  }
                }
              } |
              contract _makeVault(@ownerRevAddress, @initialAmount, ret) = {
                new revAddrCh, eitherRevAddrCh, purseCh, eitherPurseCh, mkVault in {
                  @Either!("fromNillable", ownerRevAddress, "Required `revAddress` parameter was Nil", *eitherRevAddrCh) |
                  mint!("makePurse", initialAmount, *purseCh) |
                  @Either!("fromNillable <-", *purseCh, "Couldn't create purse", *eitherPurseCh) |
                  @Either!("map2 <-", *eitherRevAddrCh, *eitherPurseCh,
                    for (@addr, purse, r <- mkVault) {
                      new necVault in {
                        _newVault!(*necVault, addr, *purse) |
                        r!(bundle+{*necVault})
                      }
                    },
                    *ret
                  )
                }
              } |
              contract _newVault(necVault, @ownRevAddress, purse) = {
                new logStore in {
                  logStore!(Nil) |
                  contract necVault(@"balance", ret) = {
                    purse!("getBalance", *ret)
                  } |
                  contract necVault(@"transfer", @revAddress, @amount, authKey, ret) = {
                    new ret2 in {
                      _transferTemplate!(ownRevAddress, *purse, revAddress, amount, *authKey, *ret2) |
                      for (@result <- ret2) {
                        ret!(result) |
                        for (logCh <<- logStore) {
                          if (Nil != *logCh) {
                            new bd(`rho:block:data`), bdCh in {
                              bd!(*bdCh) |
                              for (@blockNumber, @timestamp, @sender <- bdCh) {
                                logCh!(["transfer", revAddress, amount, result, blockNumber, timestamp, sender])
                              }
                            }
                          }
                        }
                      }
                    }
                  } |
                  contract necVault(@"setLog", logCh, authKey, ret) = {
                    new authKeyValidCh in {
                      @AuthKey!("check", *authKey, (*_necVault, ownRevAddress), *authKeyValidCh) |
                      for (@result <- authKeyValidCh) {
                        if (result) {
                          new ack in {
                            for (_ <- logStore) {
                              logStore!(*logCh) |
                              purse!("setLog", *logCh, *ack) |
                              for (_ <- ack) {
                                ret!(true)
                              }
                            }
                          }
                        } else {
                          ret!(false)
                        }
                      }
                    }
                  } |
                  contract @{ownRevAddress | bundle0{*_necVault}}(@"_deposit", depositPurse, retCh) = {
                    _depositTemplate!(*purse, *depositPurse, *retCh)
                  }
                }
              } |
              contract _transferTemplate(@ownRevAddress, purse, @revAddress, @amount, authKey, ret) = {
                new revAddressValid, revAddressValidEither, amountNonNegative,
                    authKeyValidCh, authKeyValidEitherCh,
                    parametersOkCh, parametersAndAuthOkCh,
                    split, eitherPurseCh, doDeposit
                in {
                  RevAddress!("validate", revAddress, *revAddressValid) |
                  @Either!("fromNillableError <-", *revAddressValid, *revAddressValidEither) |
                  @Either!("fromBoolean", amount >= 0, "Amount must be non-negative", *amountNonNegative) |
                  @AuthKey!("check", *authKey, (*_necVault, ownRevAddress), *authKeyValidCh) |
                  @Either!("fromBoolean <-", *authKeyValidCh, "Invalid AuthKey", *authKeyValidEitherCh) |
                  @Either!("productR <-", *revAddressValidEither, *amountNonNegative, *parametersOkCh) |
                  @Either!("productR <-", *parametersOkCh, *authKeyValidEitherCh, *parametersAndAuthOkCh) |
                  @Either!("flatMap <-", *parametersAndAuthOkCh, *split, *eitherPurseCh) |
                  for (_, retCh <- split) {
                    new amountPurseCh in {
                      purse!("split", amount, *amountPurseCh) |
                      @Either!("fromSingletonList <-", *amountPurseCh, "Insufficient funds", *retCh)
                    }
                  } |
                  @Either!("flatMap <-", *eitherPurseCh, *doDeposit, *ret) |
                  for (@p, retCh <- doDeposit) {
                    @{revAddress | bundle0{*_necVault}}!("_deposit", p, *retCh)
                  }
                }
              } |
              contract _depositTemplate(toPurse, fromPurse, retCh) = {
                new amountCh, depositSuccessCh in {
                  fromPurse!("getBalance", *amountCh) |
                  for (@amount <- amountCh) {
                    toPurse!("deposit", amount, *fromPurse, *depositSuccessCh) |
                    @Either!("fromBoolean <-", *depositSuccessCh, "BUG FOUND: purse deposit failed", *retCh)
                  }
                }
              } 
              |
              insertArbitrary!(bundle+{*NecVault}, *uriOut) |
              for(@uri <- uriOut) {
                stdout!("NEC here:")|
                stdout!(uri)|
                deployId!(uri)// |
              }
            }
          }
        }
      }
    }
  }
}      , Sig: 3045022100c5a36c0cd6...80eeba1e6bb0cdebbb61, SigAlgorithm: secp256k1, ValidAfterBlockNumber: -1
2023-11-16 13:16:04,275 [INFO ] [node-runner-18      ] [c.r.c.MultiParentCasperImpl  ]- Received DeployData #1700140563531 -- new
  BulletVault, rs(`rho:registry:insertSigned:secp256k1`), uriOut,
  rl(`rho:registry:lookup`), RevAddress(`rho:rev:address`),
  insertArbitrary(`rho:registry:insertArbitrary`),
  stdout(`rho:io:stdout`), deployId(`rho:rchain:deployId`),
  MakeMintCh, AuthKeyCh, EitherCh, TreeHashMapCh, RevVaultCh, 
  _makeVault,
  _newVault,
  _create,
  _bulletVault,
  _transferTemplate,
  _depositTemplate
in {
  rl!(`rho:rchain:makeMint`, *MakeMintCh) |
  rl!(`rho:rchain:authKey`, *AuthKeyCh) |
  rl!(`rho:lang:either`, *EitherCh) |
  rl!(`rho:lang:treeHashMap`, *TreeHashMapCh) |
  rl!(`rho:rchain:revVault`, *RevVaultCh) |
  for (@(_, MakeMint) <- MakeMintCh;
       @(_, AuthKey)  <- AuthKeyCh;
       @(_, Either)   <- EitherCh;
       @(_, RevVault) <- RevVaultCh; 
       TreeHashMap    <- TreeHashMapCh) {
    new mintCh, revMapStore, bulletMapStore, initVault, unf, authKeyCh, revHouseAddrCh in {
      // generate revHouse for holding deposited REV 
      RevAddress!("fromUnforgeable", *unf, *revHouseAddrCh) |
      @RevVault!("unforgeableAuthKey", *unf, *authKeyCh) |
      for (@revHouseVaultAuthKey <- authKeyCh;  @revHouseAddr <- revHouseAddrCh) {
        new revHouseVaultCh, _depositList in {
          @RevVault!("findOrCreate", revHouseAddr, *revHouseVaultCh) |
          deployId!(["revHouseAddr : ",revHouseAddr])|
          // mapstore for depositing REV
          TreeHashMap!("init", 2, *revMapStore) |
          // mapstore for bullet token
          TreeHashMap!("init", 2, *bulletMapStore)| 
          for (@(true, revHouseVault) <- revHouseVaultCh; @revMap <- revMapStore; @bulletMap <- bulletMapStore) {
            @MakeMint!(*mintCh) |
            for (mint <- mintCh) {
              contract initVault(name, @address, @initialAmount) = {
                new purseCh in {
                  mint!("makePurse", initialAmount, *purseCh) |
                  for (purse <- purseCh) {
                    _newVault!(*name, address, *purse)  
                  }
                }
              } |
              contract BulletVault(@"test",res) = {
                res!("test success")
              }
              |
              contract BulletVault(@"deployerAuthKey", deployerId, ret) = {
                new DeployerIdOps(`rho:rchain:deployerId:ops`),
                    revAddrCh, deployerPubKeyBytesCh
                in {
                  DeployerIdOps!("pubKeyBytes", *deployerId, *deployerPubKeyBytesCh) |
                  for (@deployerPubKeyBytes <- deployerPubKeyBytesCh) {
                    RevAddress!("fromPublicKey", deployerPubKeyBytes, *revAddrCh) |
                    for (@deployerRevAddress <- revAddrCh) {
                      @AuthKey!("make", (*_bulletVault, deployerRevAddress), *ret)
                    }
                  }
                }
              } |
              contract BulletVault(@"unforgeableAuthKey", unf, ret) = {
                new revAddrCh in {
                  RevAddress!("fromUnforgeable", *unf, *revAddrCh) |
                  for (@unfRevAddress <- revAddrCh) {
                    @AuthKey!("make", (*_bulletVault, unfRevAddress), *ret)
                  }
                }
              } |
              contract BulletVault(@"findOrCreate", @revAddress, retCh) = {
                new revAddressValidCh, revAddressValidEitherCh in {
                  RevAddress!("validate", revAddress, *revAddressValidCh) |
                  @Either!("fromNillableError <-", *revAddressValidCh, *revAddressValidEitherCh) |
                  for (@revAddressEither <- revAddressValidEitherCh) {
                    match revAddressEither {
                      (false, _) => {
                        retCh!(revAddressEither)
                      }
                      _ => {
                        new createVault, vaultCh, getVaultCh in {
                          TreeHashMap!("get", bulletMap, revAddress, *getVaultCh) |
                          for (@vault <- getVaultCh) {
                            if (vault != Nil) {
                              retCh!((true, vault))
                            } else {
                              _create!(revAddress, *createVault, *vaultCh) |
                              for (vaultRetCh <- createVault) {
                                _makeVault!(revAddress, 0, *vaultRetCh) |
                                for (@eitherVault <- vaultCh) {
                                  retCh!(eitherVault)
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              } |

              contract BulletVault(@"deposit", @amount, retCh) = {
                new DeployerIdOps(`rho:rchain:deployerId:ops`),
                    revAddrCh, deployerPubKeyBytesCh, deployerId(`rho:rchain:deployerId`)  
                in {
                  DeployerIdOps!("pubKeyBytes", *deployerId, *deployerPubKeyBytesCh) |
                  for (@deployerPubKeyBytes <- deployerPubKeyBytesCh) {
                    RevAddress!("fromPublicKey", deployerPubKeyBytes, *revAddrCh) |
                    for (@deployerRevAddress <- revAddrCh) {
                      new vaultCh, revVaultkeyCh in {
                        @RevVault!("findOrCreate", deployerRevAddress, *vaultCh) |
                        @RevVault!("deployerAuthKey", *deployerId, *revVaultkeyCh) |
                        for (@(true, vault) <- vaultCh; key <- revVaultkeyCh) {
                          // TODO: if the amount is below 10 REV, won't trigger.
                          new resultCh, ackCh, blockData(`rho:block:data`), tCh in {
                            @vault!("transfer", revHouseAddr, amount, *key, *resultCh) |
                            blockData!(*tCh) |
                            for (@result <- resultCh; @_, @t, @_ <- tCh) {
                              // TODO: If transfer failed,...
                              _depositList!("deposit", deployerRevAddress, {"timestamp":t,"amount":amount}, *ackCh)|
                              // send Bullet
                              new createVault, bulletVaultCh, balanceCh, vaultCh, vaultCh, getVaultCh in {
                                TreeHashMap!("get", bulletMap, deployerRevAddress, *getVaultCh) |
                                for (@vault <- getVaultCh) {
                                  if (vault != Nil) {
                                    @vault!("balance", *balanceCh)| 
                                    for (@balance <- balanceCh) {
                                      _create!(deployerRevAddress, *createVault, *bulletVaultCh) |
                                      for (vaultRetCh <- createVault) {
                                        _makeVault!(deployerRevAddress, amount * 2 /100 + balance, *vaultRetCh) |
                                        for (@eitherVault <- bulletVaultCh) {
                                          retCh!(eitherVault)
                                        }
                                      }
                                    }      
                                  } else {
                                    _create!(deployerRevAddress, *createVault, *bulletVaultCh) |
                                    for (vaultRetCh <- createVault) {
                                      _makeVault!(deployerRevAddress, amount * 2 /100, *vaultRetCh) |
                                      for (@eitherVault <- bulletVaultCh) {
                                        retCh!(eitherVault)
                                      }
                                    }  
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  } 
                }       
              } |

              contract BulletVault(@"withdraw", retCh) = {
                new DeployerIdOps(`rho:rchain:deployerId:ops`),
                    revAddrCh, deployerPubKeyBytesCh, RevVaultCh, deployerId(`rho:rchain:deployerId`), getBalanceCh  
                in {
                  DeployerIdOps!("pubKeyBytes", *deployerId, *deployerPubKeyBytesCh) |
                  for (@deployerPubKeyBytes <- deployerPubKeyBytesCh) {
                    RevAddress!("fromPublicKey", deployerPubKeyBytes, *revAddrCh) |
                    for (@deployerRevAddress <- revAddrCh) {                         
                      _depositList!("withdraw", deployerRevAddress, *retCh)
                    }        
                  }
                } 
              } |  

              contract _depositList(@"deposit", @deployerRevAddress, @item, ackCh) = {
                new listCh in {
                  TreeHashMap!("get", revMap, deployerRevAddress, *listCh) |
                  for (@list <- listCh) {
                    if(list == Nil) {
                      TreeHashMap!("set", revMap, deployerRevAddress, [item], *ackCh) 
                    }else{
                      TreeHashMap!("set", revMap, deployerRevAddress, list ++ [item], *ackCh) 
                    }

                  }                
                }  
              } |

              contract _depositList(@"withdraw", @deployerRevAddress, retCh) = {
                new blockData(`rho:block:data`), tCh, _remove, liCh, ret in {
                  blockData!(*tCh) |
                  TreeHashMap!("get", revMap, deployerRevAddress, *liCh) |
                  for (@_, @t, @_ <- tCh; @li <- liCh) {
                    if (li == [] or li == Nil) {
                      deployId!("No record found!")
                    } else{
                      _remove!(t, li, *ret)
                      |deployId!(["list: ", li])
                    }
                  }|
                  contract _remove (newTimeStamp, items, ret) = {
                    new resultCh, ack, removeAck in {
                      if(*items != []){
                        if (*items.nth(0).get("timestamp") < (*newTimeStamp - 200000)) {
                          @revHouseVault!("transfer", deployerRevAddress, *items.nth(0).get("amount"), revHouseVaultAuthKey, *resultCh) |
                          for (@res <- resultCh) {
                            TreeHashMap!("set", revMap, deployerRevAddress, *items.slice(1,*items.length()), *ack) |
                            for (@ackn <- ack) {
                              _remove!( *newTimeStamp, *items.slice(1,*items.length()), *removeAck)|
                              ret!(true)
                              |
                              new re1 in {
                                TreeHashMap!("get", revMap, deployerRevAddress, *re1) |
                                for (@r <- re1) {
                                  deployId!(["The removing result: ", r])
                                }
                              }  
                            }
                          }
                        }else{
                          ret!(true)|
                          retCh!(true)|
                          new re in {
                            TreeHashMap!("get", revMap, deployerRevAddress, *re) |
                            for (@lis <- re) {
                                deployId!(["Final result:", lis])
                              }
                          }    
                        } 
                      }                      
                    }       
                  }  
                }
              } |  
              contract _create(@revAddress, constructor, retCh) = {
                // The vault was not found, create a new one and set it in the bulletMap.
                new resCh, ackCh in {
                  constructor!(*resCh) |
                  for (@eitherVault <- resCh) {
                    match eitherVault {
                      (true, vault) => {
                        TreeHashMap!("set", bulletMap, revAddress, vault, *ackCh) |
                        for (_ <- ackCh) {
                          retCh!(eitherVault)
                        }
                      }
                      (false, _)    => {
                        retCh!(eitherVault)
                      }
                    }
                  }
                }
              } |
              contract _makeVault(@ownerRevAddress, @initialAmount, ret) = {
                new revAddrCh, eitherRevAddrCh, purseCh, eitherPurseCh, mkVault in {
                  @Either!("fromNillable", ownerRevAddress, "Required `revAddress` parameter was Nil", *eitherRevAddrCh) |
                  mint!("makePurse", initialAmount, *purseCh) |
                  @Either!("fromNillable <-", *purseCh, "Couldn't create purse", *eitherPurseCh) |
                  @Either!("map2 <-", *eitherRevAddrCh, *eitherPurseCh,
                    for (@addr, purse, r <- mkVault) {
                      new bulletVault in {
                        _newVault!(*bulletVault, addr, *purse) |
                        r!(bundle+{*bulletVault})
                      }
                    },
                    *ret
                  )
                }
              } |
              contract _newVault(bulletVault, @ownRevAddress, purse) = {
                new logStore in {
                  logStore!(Nil) |
                  contract bulletVault(@"balance", ret) = {
                    purse!("getBalance", *ret)
                  } |
                  contract bulletVault(@"transfer", @revAddress, @amount, authKey, ret) = {
                    new ret2 in {
                      _transferTemplate!(ownRevAddress, *purse, revAddress, amount, *authKey, *ret2) |
                      for (@result <- ret2) {
                        ret!(result) |
                        for (logCh <<- logStore) {
                          if (Nil != *logCh) {
                            new bd(`rho:block:data`), bdCh in {
                              bd!(*bdCh) |
                              for (@blockNumber, @timestamp, @sender <- bdCh) {
                                logCh!(["transfer", revAddress, amount, result, blockNumber, timestamp, sender])
                              }
                            }
                          }
                        }
                      }
                    }
                  } |
                  contract bulletVault(@"setLog", logCh, authKey, ret) = {
                    new authKeyValidCh in {
                      @AuthKey!("check", *authKey, (*_bulletVault, ownRevAddress), *authKeyValidCh) |
                      for (@result <- authKeyValidCh) {
                        if (result) {
                          new ack in {
                            for (_ <- logStore) {
                              logStore!(*logCh) |
                              purse!("setLog", *logCh, *ack) |
                              for (_ <- ack) {
                                ret!(true)
                              }
                            }
                          }
                        } else {
                          ret!(false)
                        }
                      }
                    }
                  } |
                  contract @{ownRevAddress | bundle0{*_bulletVault}}(@"_deposit", depositPurse, retCh) = {
                    _depositTemplate!(*purse, *depositPurse, *retCh)
                  }
                }
              } |
              contract _transferTemplate(@ownRevAddress, purse, @revAddress, @amount, authKey, ret) = {
                new revAddressValid, revAddressValidEither, amountNonNegative,
                    authKeyValidCh, authKeyValidEitherCh,
                    parametersOkCh, parametersAndAuthOkCh,
                    split, eitherPurseCh, doDeposit
                in {
                  RevAddress!("validate", revAddress, *revAddressValid) |
                  @Either!("fromNillableError <-", *revAddressValid, *revAddressValidEither) |
                  @Either!("fromBoolean", amount >= 0, "Amount must be non-negative", *amountNonNegative) |
                  @AuthKey!("check", *authKey, (*_bulletVault, ownRevAddress), *authKeyValidCh) |
                  @Either!("fromBoolean <-", *authKeyValidCh, "Invalid AuthKey", *authKeyValidEitherCh) |
                  @Either!("productR <-", *revAddressValidEither, *amountNonNegative, *parametersOkCh) |
                  @Either!("productR <-", *parametersOkCh, *authKeyValidEitherCh, *parametersAndAuthOkCh) |
                  @Either!("flatMap <-", *parametersAndAuthOkCh, *split, *eitherPurseCh) |
                  for (_, retCh <- split) {
                    new amountPurseCh in {
                      purse!("split", amount, *amountPurseCh) |
                      @Either!("fromSingletonList <-", *amountPurseCh, "Insufficient funds", *retCh)
                    }
                  } |
                  @Either!("flatMap <-", *eitherPurseCh, *doDeposit, *ret) |
                  for (@p, retCh <- doDeposit) {
                    @{revAddress | bundle0{*_bulletVault}}!("_deposit", p, *retCh)
                  }
                }
              } |
              contract _depositTemplate(toPurse, fromPurse, retCh) = {
                new amountCh, depositSuccessCh in {
                  fromPurse!("getBalance", *amountCh) |
                  for (@amount <- amountCh) {
                    toPurse!("deposit", amount, *fromPurse, *depositSuccessCh) |
                    @Either!("fromBoolean <-", *depositSuccessCh, "BUG FOUND: purse deposit failed", *retCh)
                  }
                }
              } 
              |
              insertArbitrary!(bundle+{*BulletVault}, *uriOut) |
              for(@uri <- uriOut) {
                stdout!("Bullet here:")|
                stdout!(uri)|
                deployId!(uri)// |
              }
            }
          }
        }
      }
    }
  }
}      , Sig: 3045022100f1c56de67a...5a970431cf7be7352a65, SigAlgorithm: secp256k1, ValidAfterBlockNumber: -1
2023-11-16 13:16:04,377 [DEBUG] [c-nio-worker-ELG-3-1] [io.perfmark.PerfMark         ]- Error during PerfMark.<clinit>
java.lang.ClassNotFoundException: io.perfmark.impl.SecretPerfMarkImpl$PerfMarkImpl
	at java.base/jdk.internal.loader.BuiltinClassLoader.loadClass(BuiltinClassLoader.java:581)
	at java.base/jdk.internal.loader.ClassLoaders$AppClassLoader.loadClass(ClassLoaders.java:178)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:527)
	at java.base/java.lang.Class.forName0(Native Method)
	at java.base/java.lang.Class.forName(Class.java:315)
	at io.perfmark.PerfMark.<clinit>(PerfMark.java:36)
	at io.grpc.netty.NettyServerStream$TransportState.<init>(NettyServerStream.java:225)
	at io.grpc.netty.NettyServerHandler.onHeadersRead(NettyServerHandler.java:439)
	at io.grpc.netty.NettyServerHandler.access$900(NettyServerHandler.java:101)
	at io.grpc.netty.NettyServerHandler$FrameListener.onHeadersRead(NettyServerHandler.java:813)
	at io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$FrameReadListener.onHeadersRead(DefaultHttp2ConnectionDecoder.java:373)
	at io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$FrameReadListener.onHeadersRead(DefaultHttp2ConnectionDecoder.java:321)
	at io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$PrefaceFrameListener.onHeadersRead(DefaultHttp2ConnectionDecoder.java:665)
	at io.netty.handler.codec.http2.Http2InboundFrameLogger$1.onHeadersRead(Http2InboundFrameLogger.java:56)
	at io.netty.handler.codec.http2.DefaultHttp2FrameReader$2.processFragment(DefaultHttp2FrameReader.java:483)
	at io.netty.handler.codec.http2.DefaultHttp2FrameReader.readHeadersFrame(DefaultHttp2FrameReader.java:491)
	at io.netty.handler.codec.http2.DefaultHttp2FrameReader.processPayloadState(DefaultHttp2FrameReader.java:254)
	at io.netty.handler.codec.http2.DefaultHttp2FrameReader.readFrame(DefaultHttp2FrameReader.java:160)
	at io.netty.handler.codec.http2.Http2InboundFrameLogger.readFrame(Http2InboundFrameLogger.java:41)
	at io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder.decodeFrame(DefaultHttp2ConnectionDecoder.java:174)
	at io.netty.handler.codec.http2.Http2ConnectionHandler$FrameDecoder.decode(Http2ConnectionHandler.java:378)
	at io.netty.handler.codec.http2.Http2ConnectionHandler$PrefaceDecoder.decode(Http2ConnectionHandler.java:242)
	at io.netty.handler.codec.http2.Http2ConnectionHandler.decode(Http2ConnectionHandler.java:438)
	at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:498)
	at io.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:437)
	at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:276)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357)
	at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1410)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)
	at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:919)
	at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:163)
	at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:714)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:650)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:576)
	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:493)
	at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:989)
	at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)
	at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
	at java.base/java.lang.Thread.run(Thread.java:829)
2023-11-16 13:16:04,401 [INFO ] [node-runner-27      ] [c.r.n.i.ProposerInstance$    ]- Propose started
2023-11-16 13:16:04,402 [DEBUG] [node-runner-18      ] [c.rchain.casper.api.BlockAPI$]- Failure: another propose is in progress
2023-11-16 13:16:05,140 [INFO ] [node-runner-18      ] [c.r.c.b.proposer.Proposer    ]- getCasperSnapshot [735.250123 ms]
2023-11-16 13:16:05,149 [INFO ] [node-runner-37      ] [alizedHeightConstraintChecker]- Latest message is 0 blocks ahead of the last finalized block
2023-11-16 13:16:05,159 [INFO ] [node-runner-24      ] [c.r.c.b.p.BlockCreator$      ]- Creating block #1 (seqNum 1)
2023-11-16 13:16:05,227 [INFO ] [node-runner-23      ] [c.r.casper.rholang.RuntimeOps]- PreCharging 04be064356846e36e485408df50b877dd99ba406d87208add4c92b3c7d4e4c663c2fbc6a1e6534c7e5c0aec00b26486fad1daf20079423b7c8ebffbbdff3682b58 for 100000000
2023-11-16 13:16:07,380 [DEBUG] [node-runner-29      ] [coop.rchain.rholang.stdout   ]- `rho:id:c1rgsjz9q7tbbg5jptqd8kpn8jzfn9trmyib166wp5sx7ejdxf1uxf`
2023-11-16 13:16:07,380 [DEBUG] [node-runner-37      ] [coop.rchain.rholang.stdout   ]- "NEC here:"
2023-11-16 13:16:07,385 [INFO ] [node-runner-37      ] [c.r.casper.rholang.RuntimeOps]- Refunding 04be064356846e36e485408df50b877dd99ba406d87208add4c92b3c7d4e4c663c2fbc6a1e6534c7e5c0aec00b26486fad1daf20079423b7c8ebffbbdff3682b58 with 99379983
2023-11-16 13:16:07,791 [INFO ] [node-runner-27      ] [c.r.casper.rholang.RuntimeOps]- PreCharging 04be064356846e36e485408df50b877dd99ba406d87208add4c92b3c7d4e4c663c2fbc6a1e6534c7e5c0aec00b26486fad1daf20079423b7c8ebffbbdff3682b58 for 100000000
2023-11-16 13:16:09,505 [DEBUG] [node-runner-26      ] [coop.rchain.rholang.stdout   ]- "Bullet here:"
2023-11-16 13:16:09,505 [DEBUG] [node-runner-29      ] [coop.rchain.rholang.stdout   ]- `rho:id:wnbdfonhkwbgy4g5y5aky8bkob9wzc1zn74b1kx8axr3c7rym39pmw`
2023-11-16 13:16:09,511 [INFO ] [node-runner-29      ] [c.r.casper.rholang.RuntimeOps]- Refunding 04be064356846e36e485408df50b877dd99ba406d87208add4c92b3c7d4e4c663c2fbc6a1e6534c7e5c0aec00b26486fad1daf20079423b7c8ebffbbdff3682b58 with 99374656
2023-11-16 13:16:10,839 [INFO ] [node-runner-24      ] [c.r.c.b.p.BlockCreator$      ]- Block created: #1 (f14f25886f...) (2d) [5.679033608 sec]
2023-11-16 13:16:10,849 [INFO ] [node-runner-24      ] [c.r.c.MultiParentCasperImpl  ]- Validating block #1 (f14f25886f...).
2023-11-16 13:16:10,936 [INFO ] [node-runner-24      ] [c.r.c.u.r.InterpreterUtil$   ]- Computed parents post state for Block #1 (f14f25886f...) -- Sender ID 042e13eadc... -- M Parent Hash e1a8c224da... -- Contents 6778d27952...-- Shard ID root.
2023-11-16 13:16:12,979 [DEBUG] [node-runner-26      ] [coop.rchain.rholang.stdout   ]- `rho:id:c1rgsjz9q7tbbg5jptqd8kpn8jzfn9trmyib166wp5sx7ejdxf1uxf`
2023-11-16 13:16:12,980 [DEBUG] [node-runner-29      ] [coop.rchain.rholang.stdout   ]- "NEC here:"
2023-11-16 13:16:15,084 [DEBUG] [node-runner-29      ] [coop.rchain.rholang.stdout   ]- "Bullet here:"
2023-11-16 13:16:15,085 [DEBUG] [node-runner-37      ] [coop.rchain.rholang.stdout   ]- `rho:id:wnbdfonhkwbgy4g5y5aky8bkob9wzc1zn74b1kx8axr3c7rym39pmw`
2023-11-16 13:16:16,064 [INFO ] [node-runner-23      ] [c.r.c.EquivocationDetector$  ]- Calculate checkNeglectedEquivocationsWithUpdate
2023-11-16 13:16:16,068 [INFO ] [node-runner-23      ] [c.r.c.EquivocationDetector$  ]- Calculate checkEquivocations.
2023-11-16 13:16:16,070 [INFO ] [node-runner-23      ] [c.r.c.MultiParentCasperImpl  ]- Block replayed: #1 (f14f25886f...) (2d) (Valid) [5.21969989 sec]
2023-11-16 13:16:16,768 [INFO ] [node-runner-25      ] [c.r.c.MultiParentCasperImpl  ]- Removed 0 deploys from deploy history as we finalized block [e1a8c224da...].
2023-11-16 13:16:16,784 [INFO ] [node-runner-25      ] [.r.c.e.BlockRetriever$$anon$1]- Block f14f25886f... is not in RequestedBlocks. Adding and marking recieved.
2023-11-16 13:16:16,789 [INFO ] [node-runner-25      ] [c.r.c.util.comm.CommUtilOps  ]- Sent hash f14f25886f... to peers
2023-11-16 13:16:16,799 [INFO ] [node-runner-23      ] [c.rchain.casper.api.BlockAPI$]- Success! Block f14f25886f3c446799191ea0f2fccf3f2a9b2ad8524430d516dab71e62c24454 created and added.
2023-11-16 13:16:16,805 [INFO ] [node-runner-25      ] [c.r.n.i.ProposerInstance$    ]- Propose finished: ProposeSuccess(Valid) Block #1 (f14f25886f...) created and added.
2023-11-16 13:16:16,807 [INFO ] [node-runner-27      ] [c.r.n.i.ProposerInstance$    ]- Propose started
2023-11-16 13:16:17,080 [INFO ] [node-runner-27      ] [c.r.c.b.proposer.Proposer    ]- getCasperSnapshot [272.500863 ms]
2023-11-16 13:16:17,083 [INFO ] [node-runner-37      ] [alizedHeightConstraintChecker]- Latest message is 1 blocks ahead of the last finalized block
2023-11-16 13:16:17,306 [INFO ] [node-runner-25      ] [.c.SynchronyConstraintChecker]- Seen 0 senders with weight 0 out of total 100002000000 (0.0 out of 0.0 needed)
2023-11-16 13:16:17,308 [INFO ] [node-runner-37      ] [c.r.c.b.p.BlockCreator$      ]- Creating block #2 (seqNum 2)
2023-11-16 13:16:17,310 [INFO ] [node-runner-37      ] [c.r.n.i.ProposerInstance$    ]- Propose failed: NoNewDeploys
2023-11-16 13:16:28,890 [DEBUG] [node-runner-24      ] [c.r.c.MultiParentCasperImpl  ]- Requesting CasperBuffer pendant hashes, 0 items.
2023-11-16 13:16:28,891 [DEBUG] [node-runner-24      ] [.r.c.e.BlockRetriever$$anon$1]- Running BlockRetriever maintenance (1 items unexpired).
2023-11-16 13:16:58,895 [DEBUG] [node-runner-37      ] [c.r.c.MultiParentCasperImpl  ]- Requesting CasperBuffer pendant hashes, 0 items.
2023-11-16 13:16:58,896 [DEBUG] [node-runner-37      ] [.r.c.e.BlockRetriever$$anon$1]- Running BlockRetriever maintenance (1 items unexpired).
2023-11-16 13:17:28,904 [DEBUG] [node-runner-23      ] [c.r.c.MultiParentCasperImpl  ]- Requesting CasperBuffer pendant hashes, 0 items.
2023-11-16 13:17:28,904 [DEBUG] [node-runner-23      ] [.r.c.e.BlockRetriever$$anon$1]- Running BlockRetriever maintenance (1 items unexpired).
2023-11-16 13:17:58,920 [DEBUG] [node-runner-18      ] [c.r.c.MultiParentCasperImpl  ]- Requesting CasperBuffer pendant hashes, 0 items.
2023-11-16 13:17:58,921 [DEBUG] [node-runner-18      ] [.r.c.e.BlockRetriever$$anon$1]- Running BlockRetriever maintenance (1 items unexpired).
2023-11-16 13:18:28,934 [DEBUG] [node-runner-29      ] [c.r.c.MultiParentCasperImpl  ]- Requesting CasperBuffer pendant hashes, 0 items.
2023-11-16 13:18:28,934 [DEBUG] [node-runner-29      ] [.r.c.e.BlockRetriever$$anon$1]- Running BlockRetriever maintenance (1 items unexpired).
2023-11-16 13:18:58,947 [DEBUG] [node-runner-37      ] [c.r.c.MultiParentCasperImpl  ]- Requesting CasperBuffer pendant hashes, 0 items.
2023-11-16 13:18:58,948 [DEBUG] [node-runner-37      ] [.r.c.e.BlockRetriever$$anon$1]- Running BlockRetriever maintenance (1 items unexpired).
2023-11-16 13:19:28,957 [DEBUG] [node-runner-24      ] [c.r.c.MultiParentCasperImpl  ]- Requesting CasperBuffer pendant hashes, 0 items.
2023-11-16 13:19:28,957 [DEBUG] [node-runner-24      ] [.r.c.e.BlockRetriever$$anon$1]- Running BlockRetriever maintenance (1 items unexpired).
2023-11-16 13:19:58,959 [DEBUG] [node-runner-23      ] [c.r.c.MultiParentCasperImpl  ]- Requesting CasperBuffer pendant hashes, 0 items.
2023-11-16 13:19:58,959 [DEBUG] [node-runner-23      ] [.r.c.e.BlockRetriever$$anon$1]- Running BlockRetriever maintenance (1 items unexpired).
2023-11-16 13:20:28,972 [DEBUG] [node-runner-27      ] [c.r.c.MultiParentCasperImpl  ]- Requesting CasperBuffer pendant hashes, 0 items.
2023-11-16 13:20:28,972 [DEBUG] [node-runner-27      ] [.r.c.e.BlockRetriever$$anon$1]- Running BlockRetriever maintenance (1 items unexpired).
2023-11-16 13:20:58,985 [DEBUG] [node-runner-27      ] [c.r.c.MultiParentCasperImpl  ]- Requesting CasperBuffer pendant hashes, 0 items.
2023-11-16 13:20:58,985 [DEBUG] [node-runner-27      ] [.r.c.e.BlockRetriever$$anon$1]- Running BlockRetriever maintenance (0 items unexpired).
2023-11-16 13:21:28,990 [DEBUG] [node-runner-27      ] [c.r.c.MultiParentCasperImpl  ]- Requesting CasperBuffer pendant hashes, 0 items.
2023-11-16 13:21:28,991 [DEBUG] [node-runner-27      ] [.r.c.e.BlockRetriever$$anon$1]- Running BlockRetriever maintenance (0 items unexpired).
2023-11-16 13:21:59,001 [DEBUG] [node-runner-29      ] [c.r.c.MultiParentCasperImpl  ]- Requesting CasperBuffer pendant hashes, 0 items.
2023-11-16 13:21:59,002 [DEBUG] [node-runner-29      ] [.r.c.e.BlockRetriever$$anon$1]- Running BlockRetriever maintenance (0 items unexpired).
2023-11-16 13:22:29,010 [DEBUG] [node-runner-24      ] [c.r.c.MultiParentCasperImpl  ]- Requesting CasperBuffer pendant hashes, 0 items.
2023-11-16 13:22:29,010 [DEBUG] [node-runner-24      ] [.r.c.e.BlockRetriever$$anon$1]- Running BlockRetriever maintenance (0 items unexpired).
2023-11-16 13:22:59,024 [DEBUG] [node-runner-23      ] [c.r.c.MultiParentCasperImpl  ]- Requesting CasperBuffer pendant hashes, 0 items.
2023-11-16 13:22:59,024 [DEBUG] [node-runner-23      ] [.r.c.e.BlockRetriever$$anon$1]- Running BlockRetriever maintenance (0 items unexpired).
2023-11-16 13:23:29,030 [DEBUG] [node-runner-24      ] [c.r.c.MultiParentCasperImpl  ]- Requesting CasperBuffer pendant hashes, 0 items.
2023-11-16 13:23:29,030 [DEBUG] [node-runner-24      ] [.r.c.e.BlockRetriever$$anon$1]- Running BlockRetriever maintenance (0 items unexpired).
2023-11-16 13:23:59,032 [DEBUG] [node-runner-18      ] [c.r.c.MultiParentCasperImpl  ]- Requesting CasperBuffer pendant hashes, 0 items.
2023-11-16 13:23:59,032 [DEBUG] [node-runner-18      ] [.r.c.e.BlockRetriever$$anon$1]- Running BlockRetriever maintenance (0 items unexpired).
2023-11-16 13:24:14,827 [DEBUG] [node-runner-29      ] [c.r.c.safety.CliqueOracle$   ]- Calculating fault tolerance for f14f25886f3c446799191ea0f2fccf3f2a9b2ad8524430d516dab71e62c24454.
2023-11-16 13:24:14,898 [INFO ] [node-runner-29      ] [c.r.c.MultiParentCasperImpl  ]- Received DeployData #1700141054766 -- new userCh, print(`rho:io:stdout`), ret in {
    contract @{"rl_factory"}(checkBalance, transfer, checkBulletBalance, depositForBullet, checkNECBalance, depositForNEC) = {
        contract checkBalance(addr, ret) = {
            new rl(`rho:registry:lookup`), RevVaultCh, vaultCh, balanceCh in {
                rl!(`rho:rchain:revVault`, *RevVaultCh) |
                for (@(_, RevVault) <- RevVaultCh) {
                    match *addr {
                        revAddress => {
                            print!(("Accessing vault at RevAddress", revAddress)) |
                            @RevVault!("findOrCreate", revAddress, *vaultCh) |
                            for (@(true, vault) <- vaultCh) {
                                print!("Obtained vault, checking balance") |
                                @vault!("balance", *balanceCh) |
                                for (@balance <- balanceCh) {
                                    ret!(balance)
                                }
                            }
                        }
                    }
                }
            }
        }
        |
        contract transfer(from, to, amount) = {
            new rl(`rho:registry:lookup`), RevVaultCh in {
                rl!(`rho:rchain:revVault`, *RevVaultCh) |
                for (@(_, RevVault) <- RevVaultCh) {
                    match (
                        *from,
                        *to,
                        *amount
                    ) {
                        (from, to, amount) => {
                            new vaultCh, targetVaultCh, revVaultkeyCh, deployerId(`rho:rchain:deployerId`) in {
                                @RevVault!("findOrCreate", from, *vaultCh) |
                                @RevVault!("findOrCreate", to, *targetVaultCh) |
                                @RevVault!("deployerAuthKey", *deployerId, *revVaultkeyCh) |
                                for (@(true, vault) <- vaultCh ; key <- revVaultkeyCh ; @(true, _) <- targetVaultCh) {
                                    print!(("Beginning transfer of ", amount, "REV from", from, "to", to)) |
                                    new resultCh in {
                                        @vault!("transfer", to, amount, *key, *resultCh) |
                                        for (@result <- resultCh) {
                                            print!(("Finished transfer of ", amount, "REV to", to, "result was:", result))
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        |
        contract checkBulletBalance(addr, ret) = {
            new rl(`rho:registry:lookup`), BulletVaultCh, vaultCh, balanceCh, res in {
                rl!(`rho:id:wnbdfonhkwbgy4g5y5aky8bkob9wzc1zn74b1kx8axr3c7rym39pmw`, *BulletVaultCh) |
                for (@BulletVault <- BulletVaultCh) {
                    match *addr {
                        revAddress => {
                            print!(("Accessing BulletVault at RevAddress", revAddress)) |
                            @BulletVault!("findOrCreate", revAddress, *vaultCh) |
                            // @BulletVault!("test", *res)|
                            // @"BulletVault"!("findOrCreate", *addr, *vaultCh) |
                            for (@(true, vault) <- vaultCh) {
                                print!("Obtained vault, checking balance") |
                                @vault!("balance", *balanceCh) |
                                for (@balance <- balanceCh) {
                                    ret!(balance)
                                }
                            }
                        }
                    }
                }
            }
        }
        |
        contract depositForBullet(amount) = {
            new rl(`rho:registry:lookup`), BulletVaultCh, retCh in {
                rl!(`rho:id:wnbdfonhkwbgy4g5y5aky8bkob9wzc1zn74b1kx8axr3c7rym39pmw`, *BulletVaultCh) |
                for (@BulletVault <- BulletVaultCh) {
                    match *amount{
                        amount => {
                            print!("start deposit")|
                            @BulletVault!("deposit", amount, *retCh) |
                            for (@result <- retCh) {
                                print!(("Finished deposit, pay amount: ", amount, "get bullet amount:", amount * 2 / 100))
                            }
                        }
                    }
                }
            }
        }
        |
        contract checkNECBalance(addr, ret) = {
            new rl(`rho:registry:lookup`), NecVaultCh, vaultCh, balanceCh, res in {
                rl!(`rho:id:c1rgsjz9q7tbbg5jptqd8kpn8jzfn9trmyib166wp5sx7ejdxf1uxf`, *NecVaultCh) |
                for (@NecVault <- NecVaultCh) {
                    match *addr {
                        revAddress => {
                            print!(("Accessing NECVault at RevAddress", revAddress)) |
                            @NecVault!("findOrCreate", revAddress, *vaultCh) |
                            // @NecVault!("test", *res)|
                            // @"NecVault"!("findOrCreate", *addr, *vaultCh) |
                            for (@(true, vault) <- vaultCh) {
                                print!("Obtained vault, checking balance") |
                                @vault!("balance", *balanceCh) |
                                for (@balance <- balanceCh) {
                                    ret!(balance)
                                }
                            }
                        }
                    }
                }
            }
        }
        |
        contract depositForNEC(amount) = {
            new rl(`rho:registry:lookup`), NecVaultCh, retCh in {
                rl!(`rho:id:c1rgsjz9q7tbbg5jptqd8kpn8jzfn9trmyib166wp5sx7ejdxf1uxf`, *NecVaultCh) |
                for (@NecVault <- NecVaultCh) {
                    match *amount{
                        amount => {
                            print!("start deposit")|
                            @NecVault!("deposit", amount, *retCh) |
                            for (@result <- retCh) {
                                print!(("Finished deposit, pay amount: ", amount, "get nec amount:", amount / 100))
                            }
                        }
                    }
                }
            }
        }
    }
}, Sig: 3045022100d13a0a0090...5c79278d8b39c868aca2, SigAlgorithm: secp256k1, ValidAfterBlockNumber: 1
2023-11-16 13:24:14,940 [INFO ] [node-runner-25      ] [c.r.n.i.ProposerInstance$    ]- Propose started
2023-11-16 13:24:15,204 [INFO ] [node-runner-24      ] [c.r.c.b.proposer.Proposer    ]- getCasperSnapshot [264.062048 ms]
2023-11-16 13:24:15,206 [INFO ] [node-runner-23      ] [alizedHeightConstraintChecker]- Latest message is 1 blocks ahead of the last finalized block
2023-11-16 13:24:15,440 [INFO ] [node-runner-27      ] [.c.SynchronyConstraintChecker]- Seen 0 senders with weight 0 out of total 100002000000 (0.0 out of 0.0 needed)
2023-11-16 13:24:15,442 [INFO ] [node-runner-26      ] [c.r.c.b.p.BlockCreator$      ]- Creating block #2 (seqNum 2)
2023-11-16 13:24:15,472 [INFO ] [node-runner-24      ] [c.r.casper.rholang.RuntimeOps]- PreCharging 04be064356846e36e485408df50b877dd99ba406d87208add4c92b3c7d4e4c663c2fbc6a1e6534c7e5c0aec00b26486fad1daf20079423b7c8ebffbbdff3682b58 for 100000000
2023-11-16 13:24:15,990 [INFO ] [node-runner-25      ] [c.r.casper.rholang.RuntimeOps]- Refunding 04be064356846e36e485408df50b877dd99ba406d87208add4c92b3c7d4e4c663c2fbc6a1e6534c7e5c0aec00b26486fad1daf20079423b7c8ebffbbdff3682b58 with 99981395
2023-11-16 13:24:16,882 [INFO ] [node-runner-24      ] [c.r.c.b.p.BlockCreator$      ]- Block created: #2 (e3266aa729...) (1d) [1.440247867 sec]
2023-11-16 13:24:16,883 [INFO ] [node-runner-24      ] [c.r.c.MultiParentCasperImpl  ]- Validating block #2 (e3266aa729...).
2023-11-16 13:24:16,922 [INFO ] [node-runner-24      ] [c.r.c.u.r.InterpreterUtil$   ]- Computed parents post state for Block #2 (e3266aa729...) -- Sender ID 042e13eadc... -- M Parent Hash f14f25886f... -- Contents 37b1189003...-- Shard ID root.
2023-11-16 13:24:18,279 [INFO ] [node-runner-23      ] [c.r.c.EquivocationDetector$  ]- Calculate checkNeglectedEquivocationsWithUpdate
2023-11-16 13:24:18,279 [INFO ] [node-runner-23      ] [c.r.c.EquivocationDetector$  ]- Calculate checkEquivocations.
2023-11-16 13:24:18,280 [INFO ] [node-runner-23      ] [c.r.c.MultiParentCasperImpl  ]- Block replayed: #2 (e3266aa729...) (1d) (Valid) [1.396521175 sec]
2023-11-16 13:24:18,408 [INFO ] [node-runner-24      ] [c.r.c.MultiParentCasperImpl  ]- Removed 0 deploys from deploy history as we finalized block [e1a8c224da...].
2023-11-16 13:24:18,418 [INFO ] [node-runner-24      ] [.r.c.e.BlockRetriever$$anon$1]- Block e3266aa729... is not in RequestedBlocks. Adding and marking recieved.
2023-11-16 13:24:18,419 [INFO ] [node-runner-24      ] [c.r.c.util.comm.CommUtilOps  ]- Sent hash e3266aa729... to peers
2023-11-16 13:24:18,421 [INFO ] [node-runner-24      ] [c.r.n.i.ProposerInstance$    ]- Propose finished: ProposeSuccess(Valid) Block #2 (e3266aa729...) created and added.
2023-11-16 13:24:18,421 [INFO ] [node-runner-27      ] [c.rchain.casper.api.BlockAPI$]- Success! Block e3266aa7296d048caceec8de4c2062fc39a4ae6c4ff2df82f98a17a11d10c6ea created and added.
2023-11-16 13:24:29,047 [DEBUG] [node-runner-18      ] [c.r.c.MultiParentCasperImpl  ]- Requesting CasperBuffer pendant hashes, 0 items.
2023-11-16 13:24:29,048 [DEBUG] [node-runner-18      ] [.r.c.e.BlockRetriever$$anon$1]- Running BlockRetriever maintenance (1 items unexpired).
2023-11-16 13:24:59,051 [DEBUG] [node-runner-23      ] [c.r.c.MultiParentCasperImpl  ]- Requesting CasperBuffer pendant hashes, 0 items.
2023-11-16 13:24:59,051 [DEBUG] [node-runner-23      ] [.r.c.e.BlockRetriever$$anon$1]- Running BlockRetriever maintenance (1 items unexpired).
2023-11-16 13:25:29,056 [DEBUG] [node-runner-18      ] [c.r.c.MultiParentCasperImpl  ]- Requesting CasperBuffer pendant hashes, 0 items.
2023-11-16 13:25:29,056 [DEBUG] [node-runner-18      ] [.r.c.e.BlockRetriever$$anon$1]- Running BlockRetriever maintenance (1 items unexpired).
2023-11-16 13:25:59,065 [DEBUG] [node-runner-37      ] [c.r.c.MultiParentCasperImpl  ]- Requesting CasperBuffer pendant hashes, 0 items.
2023-11-16 13:25:59,066 [DEBUG] [node-runner-37      ] [.r.c.e.BlockRetriever$$anon$1]- Running BlockRetriever maintenance (1 items unexpired).
2023-11-16 13:26:29,079 [DEBUG] [node-runner-23      ] [c.r.c.MultiParentCasperImpl  ]- Requesting CasperBuffer pendant hashes, 0 items.
2023-11-16 13:26:29,079 [DEBUG] [node-runner-23      ] [.r.c.e.BlockRetriever$$anon$1]- Running BlockRetriever maintenance (1 items unexpired).
2023-11-16 13:26:59,089 [DEBUG] [node-runner-24      ] [c.r.c.MultiParentCasperImpl  ]- Requesting CasperBuffer pendant hashes, 0 items.
2023-11-16 13:26:59,089 [DEBUG] [node-runner-24      ] [.r.c.e.BlockRetriever$$anon$1]- Running BlockRetriever maintenance (1 items unexpired).
2023-11-16 13:27:29,090 [DEBUG] [node-runner-24      ] [c.r.c.MultiParentCasperImpl  ]- Requesting CasperBuffer pendant hashes, 0 items.
2023-11-16 13:27:29,091 [DEBUG] [node-runner-24      ] [.r.c.e.BlockRetriever$$anon$1]- Running BlockRetriever maintenance (1 items unexpired).
