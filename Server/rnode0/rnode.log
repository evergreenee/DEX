2023-11-19 06:34:16,460 [INFO ] [main                ] [coop.rchain.node.Main$       ]- RChain Node 0.13.0-alpha3 (c766347c6df06d813f802ae9e4ca1186647cf070)
2023-11-19 06:34:16,463 [INFO ] [main                ] [coop.rchain.node.Main$       ]- Starting with profile default
2023-11-19 06:34:16,464 [INFO ] [main                ] [coop.rchain.node.Main$       ]- Using configuration file: /home/nardack/Desktop/DEX/Server/config.conf
2023-11-19 06:34:16,464 [INFO ] [main                ] [coop.rchain.node.Main$       ]- Running on network: testnet
2023-11-19 06:34:16,639 [INFO ] [main                ] [c.r.node.NodeEnvironment$    ]- Using data dir: /home/nardack/Desktop/DEX/Server/rnode0
2023-11-19 06:34:16,644 [INFO ] [main                ] [t.GenerateCertificateIfAbsent]- No certificate found at path rnode0/node.certificate.pem
2023-11-19 06:34:16,645 [INFO ] [main                ] [t.GenerateCertificateIfAbsent]- Generating a X.509 certificate for the node
2023-11-19 06:34:16,647 [INFO ] [main                ] [t.GenerateCertificateIfAbsent]- Generating a PEM secret key for the node
2023-11-19 06:34:16,922 [DEBUG] [main                ] [jdk.event.security           ]- X509Certificate: Alg:SHA256withECDSA, Serial:f769f98dec647dc7, Subject:CN=6b579d191be21cad7cbe0a96bef0df1ecd4f2d8b, Issuer:CN=6b579d191be21cad7cbe0a96bef0df1ecd4f2d8b, Key type:EC, Length:256, Cert Id:819121167, Valid from:2023/11/19 下午2:34, Valid until:2024/11/18 下午2:34
2023-11-19 06:34:17,195 [DEBUG] [main                ] [c.r.s.LmdbStoreManagerImpl   ]- Creating LMDB environment: rnode0/dagstorage
2023-11-19 06:34:17,458 [DEBUG] [main                ] [c.r.s.LmdbStoreManagerImpl   ]- Creating LMDB database: last-finalized-block, env: rnode0/dagstorage
2023-11-19 06:34:17,483 [INFO ] [main                ] [c.r.b.dag.BlockMetadataStore$]- Building in-memory blockMetadataStore.
2023-11-19 06:34:17,485 [DEBUG] [main                ] [c.r.s.LmdbStoreManagerImpl   ]- Creating LMDB database: block-metadata, env: rnode0/dagstorage
2023-11-19 06:34:17,494 [INFO ] [main                ] [c.r.b.dag.BlockMetadataStore$]- Reading data from blockMetadataStore done.
2023-11-19 06:34:17,521 [INFO ] [main                ] [c.r.b.dag.BlockMetadataStore$]- Successfully built in-memory blockMetadataStore.
2023-11-19 06:34:17,535 [DEBUG] [main                ] [c.r.s.LmdbStoreManagerImpl   ]- Creating LMDB environment: rnode0/casperbuffer
2023-11-19 06:34:17,536 [DEBUG] [main                ] [c.r.s.LmdbStoreManagerImpl   ]- Creating LMDB database: parents-map, env: rnode0/casperbuffer
2023-11-19 06:34:17,639 [DEBUG] [main                ] [c.r.s.LmdbStoreManagerImpl   ]- Creating LMDB environment: rnode0/eval/history
2023-11-19 06:34:17,641 [DEBUG] [main                ] [c.r.s.LmdbStoreManagerImpl   ]- Creating LMDB database: eval-roots, env: rnode0/eval/history
2023-11-19 06:34:17,687 [DEBUG] [main                ] [c.r.s.LmdbStoreManagerImpl   ]- Creating LMDB database: eval-history, env: rnode0/eval/history
2023-11-19 06:34:19,052 [DEBUG] [main                ] [c.r.s.LmdbStoreManagerImpl   ]- Creating LMDB environment: rnode0/rspace/history
2023-11-19 06:34:19,054 [DEBUG] [main                ] [c.r.s.LmdbStoreManagerImpl   ]- Creating LMDB database: rspace-roots, env: rnode0/rspace/history
2023-11-19 06:34:19,059 [DEBUG] [main                ] [c.r.s.LmdbStoreManagerImpl   ]- Creating LMDB database: rspace-history, env: rnode0/rspace/history
2023-11-19 06:34:19,381 [DEBUG] [node-runner-19      ] [c.r.s.LmdbStoreManagerImpl   ]- Creating LMDB database: blocks-approved, env: rnode0/dagstorage
2023-11-19 06:34:19,386 [INFO ] [node-runner-19      ] [c.r.c.e.CasperLaunch$$anon$1 ]- Approved block not found, taking part in ceremony as ceremony master
2023-11-19 06:34:19,403 [INFO ] [node-runner-19      ] [c.r.casper.util.VaultParser$ ]- Parsing wallets file rnode0/genesis/wallets.txt.
2023-11-19 06:34:19,513 [INFO ] [node-runner-19      ] [c.r.casper.util.VaultParser$ ]- Wallet loaded: 1111Wbd8KLeWBVsxByF9iksJ4QRRjEF3nq1ScgAw7bMbtomxHsqqd,1000000000000000,0
2023-11-19 06:34:19,515 [INFO ] [node-runner-19      ] [c.r.casper.util.VaultParser$ ]- Wallet loaded: 1111235s1WgxZjTRi1McWXNtys53mhUSmXoRq72YMzGL6v12fkLFHv,100000000,0
2023-11-19 06:34:19,516 [INFO ] [node-runner-19      ] [c.r.casper.util.VaultParser$ ]- Wallet loaded: 11112Bqt2LBKM2k5UbS9twPzf7VzhCuNt8Tj1ncVQruA1hhMDJWpfB,1000,0
2023-11-19 06:34:19,540 [INFO ] [node-runner-19      ] [c.r.casper.util.BondsParser$ ]- Parsing bonds file rnode0/genesis/bonds.txt.
2023-11-19 06:34:19,580 [INFO ] [node-runner-19      ] [c.r.casper.util.BondsParser$ ]- Bond loaded 04be064356846e36e485408df50b877dd99ba406d87208add4c92b3c7d4e4c663c2fbc6a1e6534c7e5c0aec00b26486fad1daf20079423b7c8ebffbbdff3682b58 => 100000000000
2023-11-19 06:34:19,582 [INFO ] [node-runner-19      ] [c.r.casper.util.BondsParser$ ]- Bond loaded 042e13eadc97fb886eed6ba8fda1f1aa5d1cb653f1fcb765cf03c9cfdcba01aa79f367ec0dd86bf8a0508110aa97b66fdf7139fa8bbac86a8b9c1dac20e656574c => 1000000
2023-11-19 06:34:19,585 [INFO ] [node-runner-19      ] [c.r.casper.util.BondsParser$ ]- Bond loaded 049ab5d17cda550253f76425d33c69891a99a6d00d7b190767305e493ce5b35f823a1ec144c9242c1ceb5e915095dabaff30f6fea48c5dcb213c6fb7a87050f657 => 1000000
2023-11-19 06:34:19,587 [INFO ] [node-runner-19      ] [c.r.casper.util.BondsParser$ ]- Bond loaded 04d34d5f438e9db72725489b54e8012f856d9a26e3ab4dea6e5938bdf91b7d7952e6ebb263450315d71176d1718681fd9814c330cfac07e8b9b8d84e6c72dfdd78 => 1000000
2023-11-19 06:34:20,884 [DEBUG] [node-runner-37      ] [c.r.s.LmdbStoreManagerImpl   ]- Creating LMDB environment: rnode0/rspace/cold
2023-11-19 06:34:20,885 [DEBUG] [node-runner-37      ] [c.r.s.LmdbStoreManagerImpl   ]- Creating LMDB database: rspace-cold, env: rnode0/rspace/cold
2023-11-19 06:34:30,671 [DEBUG] [node-runner-29      ] [c.r.s.LmdbStoreManagerImpl   ]- Creating LMDB database: mergeable-channel-cache, env: rnode0/dagstorage
2023-11-19 06:34:30,996 [INFO ] [node-runner-29      ] [c.r.node.runtime.NodeRuntime ]- Starting stand-alone node.
2023-11-19 06:34:32,142 [INFO ] [node-runner-29      ] [c.r.n.r.ServersInstances$    ]- HTTP API server started at 192.168.59.133:40403
2023-11-19 06:34:32,157 [INFO ] [node-runner-29      ] [c.r.n.r.ServersInstances$    ]- Admin HTTP API server started at 192.168.59.133:40405
2023-11-19 06:34:32,270 [INFO ] [node-runner-19      ] [ocol$ApproveBlockProtocolImpl]- Starting execution of ApprovedBlockProtocol. Waiting for 0 approvals from genesis validators.
2023-11-19 06:34:32,271 [INFO ] [node-runner-19      ] [ocol$ApproveBlockProtocolImpl]- Self-approving genesis block.
2023-11-19 06:34:32,278 [DEBUG] [node-runner-37      ] [.r.c.e.BlockRetriever$$anon$1]- Running BlockRetriever maintenance (0 items unexpired).
2023-11-19 06:34:32,290 [INFO ] [node-runner-19      ] [ocol$ApproveBlockProtocolImpl]- Sending ApprovedBlock af02b030eb... to peers...
2023-11-19 06:34:32,296 [INFO ] [node-runner-19      ] [ocol$ApproveBlockProtocolImpl]- Finished execution of ApprovedBlockProtocol
2023-11-19 06:34:32,384 [INFO ] [node-runner-25      ] [c.r.n.r.ServersInstances$    ]- Kademlia RPC server started at 192.168.59.133:40404
2023-11-19 06:34:32,384 [INFO ] [node-runner-26      ] [c.r.n.r.ServersInstances$    ]- Internal API server started at 192.168.59.133:40402
2023-11-19 06:34:32,384 [INFO ] [node-runner-38      ] [c.r.n.r.ServersInstances$    ]- External API server started at 192.168.59.133:40401
2023-11-19 06:34:32,395 [DEBUG] [node-runner-27      ] [jdk.event.security           ]- X509Certificate: Alg:SHA256withRSA, Serial:752bd03efd500194, Subject:CN=example.com, Issuer:CN=example.com, Key type:RSA, Length:2048, Cert Id:1467855822, Valid from:2018/4/7 上午6:06, Valid until:10000/1/1 上午7:59
2023-11-19 06:34:32,531 [INFO ] [node-runner-27      ] [c.r.n.r.ServersInstances$    ]- Listening for traffic on rnode://6b579d191be21cad7cbe0a96bef0df1ecd4f2d8b@192.168.59.133?protocol=40400&discovery=40404.
2023-11-19 06:34:33,017 [DEBUG] [node-runner-25      ] [c.r.s.LmdbStoreManagerImpl   ]- Creating LMDB environment: rnode0/blockstorage
2023-11-19 06:34:33,018 [DEBUG] [node-runner-25      ] [c.r.s.LmdbStoreManagerImpl   ]- Creating LMDB database: blocks, env: rnode0/blockstorage
2023-11-19 06:34:33,031 [WARN ] [node-runner-25      ] [.b.d.BlockDagKeyValueStorage$]- Block Block #0 (af02b030eb...) with empty parents (supposedly genesis) sender is empty.
2023-11-19 06:34:33,042 [DEBUG] [node-runner-25      ] [c.r.s.LmdbStoreManagerImpl   ]- Creating LMDB database: deploy-index, env: rnode0/dagstorage
2023-11-19 06:34:33,049 [DEBUG] [node-runner-25      ] [c.r.s.LmdbStoreManagerImpl   ]- Creating LMDB database: latest-messages, env: rnode0/dagstorage
2023-11-19 06:34:33,067 [DEBUG] [node-runner-25      ] [c.r.s.LmdbStoreManagerImpl   ]- Creating LMDB database: invalid-blocks, env: rnode0/dagstorage
2023-11-19 06:34:33,093 [INFO ] [node-runner-25      ] [c.r.casper.engine.Engine$    ]- Making a transition to Running state. Approved Block #0 (af02b030eb...) with empty parents (supposedly genesis)
2023-11-19 06:34:33,118 [INFO ] [node-runner-25      ] [c.r.c.util.comm.CommUtilOps  ]- Requested fork tip from peers
2023-11-19 06:34:35,967 [DEBUG] [node-runner-25      ] [c.r.c.safety.CliqueOracle$   ]- Calculating fault tolerance for af02b030eb5f649301d89388f032d48afb406f386546e335c3b65c754ebf8931.
2023-11-19 06:34:35,967 [DEBUG] [node-runner-27      ] [c.r.c.safety.CliqueOracle$   ]- Calculating fault tolerance for af02b030eb5f649301d89388f032d48afb406f386546e335c3b65c754ebf8931.
2023-11-19 06:34:36,025 [DEBUG] [node-runner-25      ] [c.r.s.LmdbStoreManagerImpl   ]- Creating LMDB database: equivocation-tracker, env: rnode0/dagstorage
2023-11-19 06:34:36,350 [DEBUG] [node-runner-24      ] [c.r.s.LmdbStoreManagerImpl   ]- Creating LMDB environment: rnode0/deploystorage
2023-11-19 06:34:36,351 [DEBUG] [node-runner-24      ] [c.r.s.LmdbStoreManagerImpl   ]- Creating LMDB database: deploy_storage, env: rnode0/deploystorage
2023-11-19 06:34:36,355 [INFO ] [node-runner-38      ] [c.r.c.MultiParentCasperImpl  ]- Received DeployData #1700375675524 -- new
  NecVault, rs(`rho:registry:insertSigned:secp256k1`), uriOut,
  rl(`rho:registry:lookup`), RevAddress(`rho:rev:address`),
  insertArbitrary(`rho:registry:insertArbitrary`),
  stdout(`rho:io:stdout`), deployId(`rho:rchain:deployId`),
  MakeMintCh, AuthKeyCh, EitherCh, TreeHashMapCh, RevVaultCh, 
  _makeVault,
  _newVault,
  _create,
  _necVault,
  _transferTemplate,
  _depositTemplate
in {
  rl!(`rho:rchain:makeMint`, *MakeMintCh) |
  rl!(`rho:rchain:authKey`, *AuthKeyCh) |
  rl!(`rho:lang:either`, *EitherCh) |
  rl!(`rho:lang:treeHashMap`, *TreeHashMapCh) |
  rl!(`rho:rchain:revVault`, *RevVaultCh) |
  for (@(_, MakeMint) <- MakeMintCh;
       @(_, AuthKey)  <- AuthKeyCh;
       @(_, Either)   <- EitherCh;
       @(_, RevVault) <- RevVaultCh; 
       TreeHashMap    <- TreeHashMapCh) {
    new mintCh, revMapStore, necMapStore, initVault, unf, authKeyCh, revHouseAddrCh in {
      // generate revHouse for holding deposited REV 
      RevAddress!("fromUnforgeable", *unf, *revHouseAddrCh) |
      @RevVault!("unforgeableAuthKey", *unf, *authKeyCh) |
      for (@revHouseVaultAuthKey <- authKeyCh;  @revHouseAddr <- revHouseAddrCh) {
        new revHouseVaultCh, _depositList in {
          @RevVault!("findOrCreate", revHouseAddr, *revHouseVaultCh) |
          deployId!(["revHouseAddr : ",revHouseAddr])|
          // mapstore for depositing REV
          TreeHashMap!("init", 2, *revMapStore) |
          // mapstore for nec token
          TreeHashMap!("init", 2, *necMapStore)| 
          for (@(true, revHouseVault) <- revHouseVaultCh; @revMap <- revMapStore; @necMap <- necMapStore) {
            @MakeMint!(*mintCh) |
            for (mint <- mintCh) {
              contract initVault(name, @address, @initialAmount) = {
                new purseCh in {
                  mint!("makePurse", initialAmount, *purseCh) |
                  for (purse <- purseCh) {
                    _newVault!(*name, address, *purse)  
                  }
                }
              } |
              contract NecVault(@"test",res) = {
                res!("test success")
              }
              |
              contract NecVault(@"deployerAuthKey", deployerId, ret) = {
                new DeployerIdOps(`rho:rchain:deployerId:ops`),
                    revAddrCh, deployerPubKeyBytesCh
                in {
                  DeployerIdOps!("pubKeyBytes", *deployerId, *deployerPubKeyBytesCh) |
                  for (@deployerPubKeyBytes <- deployerPubKeyBytesCh) {
                    RevAddress!("fromPublicKey", deployerPubKeyBytes, *revAddrCh) |
                    for (@deployerRevAddress <- revAddrCh) {
                      @AuthKey!("make", (*_necVault, deployerRevAddress), *ret)
                    }
                  }
                }
              } |
              contract NecVault(@"unforgeableAuthKey", unf, ret) = {
                new revAddrCh in {
                  RevAddress!("fromUnforgeable", *unf, *revAddrCh) |
                  for (@unfRevAddress <- revAddrCh) {
                    @AuthKey!("make", (*_necVault, unfRevAddress), *ret)
                  }
                }
              } |
              contract NecVault(@"findOrCreate", @revAddress, retCh) = {
                new revAddressValidCh, revAddressValidEitherCh in {
                  RevAddress!("validate", revAddress, *revAddressValidCh) |
                  @Either!("fromNillableError <-", *revAddressValidCh, *revAddressValidEitherCh) |
                  for (@revAddressEither <- revAddressValidEitherCh) {
                    match revAddressEither {
                      (false, _) => {
                        retCh!(revAddressEither)
                      }
                      _ => {
                        new createVault, vaultCh, getVaultCh in {
                          TreeHashMap!("get", necMap, revAddress, *getVaultCh) |
                          for (@vault <- getVaultCh) {
                            if (vault != Nil) {
                              retCh!((true, vault))
                            } else {
                              _create!(revAddress, *createVault, *vaultCh) |
                              for (vaultRetCh <- createVault) {
                                _makeVault!(revAddress, 0, *vaultRetCh) |
                                for (@eitherVault <- vaultCh) {
                                  retCh!(eitherVault)
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              } |

              contract NecVault(@"deposit", @amount, @rate, retCh) = {
                new DeployerIdOps(`rho:rchain:deployerId:ops`),
                    revAddrCh, deployerPubKeyBytesCh, deployerId(`rho:rchain:deployerId`)  
                in {
                  DeployerIdOps!("pubKeyBytes", *deployerId, *deployerPubKeyBytesCh) |
                  for (@deployerPubKeyBytes <- deployerPubKeyBytesCh) {
                    RevAddress!("fromPublicKey", deployerPubKeyBytes, *revAddrCh) |
                    for (@deployerRevAddress <- revAddrCh) {
                      new vaultCh, revVaultkeyCh in {
                        @RevVault!("findOrCreate", deployerRevAddress, *vaultCh) |
                        @RevVault!("deployerAuthKey", *deployerId, *revVaultkeyCh) |
                        for (@(true, vault) <- vaultCh; key <- revVaultkeyCh) {
                          // TODO: if the amount is below 10 REV, won't trigger.
                          new resultCh, ackCh, blockData(`rho:block:data`), tCh in {
                            @vault!("transfer", revHouseAddr, amount, *key, *resultCh) |
                            blockData!(*tCh) |
                            for (@result <- resultCh; @_, @t, @_ <- tCh) {
                              // TODO: If transfer failed,...
                              _depositList!("deposit", deployerRevAddress, {"timestamp":t,"amount":amount}, *ackCh)|
                              // send NEC
                              new createVault, necVaultCh, balanceCh, vaultCh, vaultCh, getVaultCh in {
                                TreeHashMap!("get", necMap, deployerRevAddress, *getVaultCh) |
                                for (@vault <- getVaultCh) {
                                  if (vault != Nil) {
                                    @vault!("balance", *balanceCh)| 
                                    for (@balance <- balanceCh) {
                                      _create!(deployerRevAddress, *createVault, *necVaultCh) |
                                      for (vaultRetCh <- createVault) {
                                        _makeVault!(deployerRevAddress, amount / rate + balance, *vaultRetCh) |
                                        for (@eitherVault <- necVaultCh) {
                                          retCh!(eitherVault)
                                        }
                                      }
                                    }      
                                  } else {
                                    _create!(deployerRevAddress, *createVault, *necVaultCh) |
                                    for (vaultRetCh <- createVault) {
                                      _makeVault!(deployerRevAddress, amount / rate, *vaultRetCh) |
                                      for (@eitherVault <- necVaultCh) {
                                        retCh!(eitherVault)
                                      }
                                    }  
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  } 
                }       
              } |

              contract _depositList(@"deposit", @deployerRevAddress, @item, ackCh) = {
                new listCh in {
                  TreeHashMap!("get", revMap, deployerRevAddress, *listCh) |
                  for (@list <- listCh) {
                    if(list == Nil) {
                      TreeHashMap!("set", revMap, deployerRevAddress, [item], *ackCh) 
                    }else{
                      TreeHashMap!("set", revMap, deployerRevAddress, list ++ [item], *ackCh) 
                    }

                  }                
                }  
              } |
              contract _create(@revAddress, constructor, retCh) = {
                // The vault was not found, create a new one and set it in the necMap.
                new resCh, ackCh in {
                  constructor!(*resCh) |
                  for (@eitherVault <- resCh) {
                    match eitherVault {
                      (true, vault) => {
                        TreeHashMap!("set", necMap, revAddress, vault, *ackCh) |
                        for (_ <- ackCh) {
                          retCh!(eitherVault)
                        }
                      }
                      (false, _)    => {
                        retCh!(eitherVault)
                      }
                    }
                  }
                }
              } |
              contract _makeVault(@ownerRevAddress, @initialAmount, ret) = {
                new revAddrCh, eitherRevAddrCh, purseCh, eitherPurseCh, mkVault in {
                  @Either!("fromNillable", ownerRevAddress, "Required `revAddress` parameter was Nil", *eitherRevAddrCh) |
                  mint!("makePurse", initialAmount, *purseCh) |
                  @Either!("fromNillable <-", *purseCh, "Couldn't create purse", *eitherPurseCh) |
                  @Either!("map2 <-", *eitherRevAddrCh, *eitherPurseCh,
                    for (@addr, purse, r <- mkVault) {
                      new necVault in {
                        _newVault!(*necVault, addr, *purse) |
                        r!(bundle+{*necVault})
                      }
                    },
                    *ret
                  )
                }
              } |
              contract _newVault(necVault, @ownRevAddress, purse) = {
                new logStore in {
                  logStore!(Nil) |
                  contract necVault(@"balance", ret) = {
                    purse!("getBalance", *ret)
                  } |
                  contract necVault(@"transfer", @revAddress, @amount, authKey, ret) = {
                    new ret2 in {
                      _transferTemplate!(ownRevAddress, *purse, revAddress, amount, *authKey, *ret2) |
                      for (@result <- ret2) {
                        ret!(result) |
                        for (logCh <<- logStore) {
                          if (Nil != *logCh) {
                            new bd(`rho:block:data`), bdCh in {
                              bd!(*bdCh) |
                              for (@blockNumber, @timestamp, @sender <- bdCh) {
                                logCh!(["transfer", revAddress, amount, result, blockNumber, timestamp, sender])
                              }
                            }
                          }
                        }
                      }
                    }
                  } |
                  contract necVault(@"setLog", logCh, authKey, ret) = {
                    new authKeyValidCh in {
                      @AuthKey!("check", *authKey, (*_necVault, ownRevAddress), *authKeyValidCh) |
                      for (@result <- authKeyValidCh) {
                        if (result) {
                          new ack in {
                            for (_ <- logStore) {
                              logStore!(*logCh) |
                              purse!("setLog", *logCh, *ack) |
                              for (_ <- ack) {
                                ret!(true)
                              }
                            }
                          }
                        } else {
                          ret!(false)
                        }
                      }
                    }
                  } |
                  contract @{ownRevAddress | bundle0{*_necVault}}(@"_deposit", depositPurse, retCh) = {
                    _depositTemplate!(*purse, *depositPurse, *retCh)
                  }
                }
              } |
              contract _transferTemplate(@ownRevAddress, purse, @revAddress, @amount, authKey, ret) = {
                new revAddressValid, revAddressValidEither, amountNonNegative,
                    authKeyValidCh, authKeyValidEitherCh,
                    parametersOkCh, parametersAndAuthOkCh,
                    split, eitherPurseCh, doDeposit
                in {
                  RevAddress!("validate", revAddress, *revAddressValid) |
                  @Either!("fromNillableError <-", *revAddressValid, *revAddressValidEither) |
                  @Either!("fromBoolean", amount >= 0, "Amount must be non-negative", *amountNonNegative) |
                  @AuthKey!("check", *authKey, (*_necVault, ownRevAddress), *authKeyValidCh) |
                  @Either!("fromBoolean <-", *authKeyValidCh, "Invalid AuthKey", *authKeyValidEitherCh) |
                  @Either!("productR <-", *revAddressValidEither, *amountNonNegative, *parametersOkCh) |
                  @Either!("productR <-", *parametersOkCh, *authKeyValidEitherCh, *parametersAndAuthOkCh) |
                  @Either!("flatMap <-", *parametersAndAuthOkCh, *split, *eitherPurseCh) |
                  for (_, retCh <- split) {
                    new amountPurseCh in {
                      purse!("split", amount, *amountPurseCh) |
                      @Either!("fromSingletonList <-", *amountPurseCh, "Insufficient funds", *retCh)
                    }
                  } |
                  @Either!("flatMap <-", *eitherPurseCh, *doDeposit, *ret) |
                  for (@p, retCh <- doDeposit) {
                    @{revAddress | bundle0{*_necVault}}!("_deposit", p, *retCh)
                  }
                }
              } |
              contract _depositTemplate(toPurse, fromPurse, retCh) = {
                new amountCh, depositSuccessCh in {
                  fromPurse!("getBalance", *amountCh) |
                  for (@amount <- amountCh) {
                    toPurse!("deposit", amount, *fromPurse, *depositSuccessCh) |
                    @Either!("fromBoolean <-", *depositSuccessCh, "BUG FOUND: purse deposit failed", *retCh)
                  }
                }
              } 
              |
              insertArbitrary!(bundle+{*NecVault}, *uriOut) |
              for(@uri <- uriOut) {
                stdout!("NEC here:")|
                stdout!(uri)|
                deployId!(uri)// |
              }
            }
          }
        }
      }
    }
  }
}      , Sig: 3045022100889e0986c9...8f611cdf4f4226310a89, SigAlgorithm: secp256k1, ValidAfterBlockNumber: -1
2023-11-19 06:34:36,355 [INFO ] [node-runner-24      ] [c.r.c.MultiParentCasperImpl  ]- Received DeployData #1700375675522 -- new
  BulletVault, rs(`rho:registry:insertSigned:secp256k1`), uriOut,
  rl(`rho:registry:lookup`), RevAddress(`rho:rev:address`),
  insertArbitrary(`rho:registry:insertArbitrary`),
  stdout(`rho:io:stdout`), deployId(`rho:rchain:deployId`),
  MakeMintCh, AuthKeyCh, EitherCh, TreeHashMapCh, RevVaultCh, 
  _makeVault,
  _newVault,
  _create,
  _bulletVault,
  _transferTemplate,
  _depositTemplate
in {
  rl!(`rho:rchain:makeMint`, *MakeMintCh) |
  rl!(`rho:rchain:authKey`, *AuthKeyCh) |
  rl!(`rho:lang:either`, *EitherCh) |
  rl!(`rho:lang:treeHashMap`, *TreeHashMapCh) |
  rl!(`rho:rchain:revVault`, *RevVaultCh) |
  for (@(_, MakeMint) <- MakeMintCh;
       @(_, AuthKey)  <- AuthKeyCh;
       @(_, Either)   <- EitherCh;
       @(_, RevVault) <- RevVaultCh; 
       TreeHashMap    <- TreeHashMapCh) {
    new mintCh, revMapStore, bulletMapStore, initVault, unf, authKeyCh, revHouseAddrCh in {
      // generate revHouse for holding deposited REV 
      RevAddress!("fromUnforgeable", *unf, *revHouseAddrCh) |
      @RevVault!("unforgeableAuthKey", *unf, *authKeyCh) |
      for (@revHouseVaultAuthKey <- authKeyCh;  @revHouseAddr <- revHouseAddrCh) {
        new revHouseVaultCh, _depositList in {
          @RevVault!("findOrCreate", revHouseAddr, *revHouseVaultCh) |
          deployId!(["revHouseAddr : ",revHouseAddr])|
          // mapstore for depositing REV
          TreeHashMap!("init", 2, *revMapStore) |
          // mapstore for bullet token
          TreeHashMap!("init", 2, *bulletMapStore)| 
          for (@(true, revHouseVault) <- revHouseVaultCh; @revMap <- revMapStore; @bulletMap <- bulletMapStore) {
            @MakeMint!(*mintCh) |
            for (mint <- mintCh) {
              contract initVault(name, @address, @initialAmount) = {
                new purseCh in {
                  mint!("makePurse", initialAmount, *purseCh) |
                  for (purse <- purseCh) {
                    _newVault!(*name, address, *purse)  
                  }
                }
              } |
              contract BulletVault(@"test",res) = {
                res!("test success")
              }
              |
              contract BulletVault(@"deployerAuthKey", deployerId, ret) = {
                new DeployerIdOps(`rho:rchain:deployerId:ops`),
                    revAddrCh, deployerPubKeyBytesCh
                in {
                  DeployerIdOps!("pubKeyBytes", *deployerId, *deployerPubKeyBytesCh) |
                  for (@deployerPubKeyBytes <- deployerPubKeyBytesCh) {
                    RevAddress!("fromPublicKey", deployerPubKeyBytes, *revAddrCh) |
                    for (@deployerRevAddress <- revAddrCh) {
                      @AuthKey!("make", (*_bulletVault, deployerRevAddress), *ret)
                    }
                  }
                }
              } |
              contract BulletVault(@"unforgeableAuthKey", unf, ret) = {
                new revAddrCh in {
                  RevAddress!("fromUnforgeable", *unf, *revAddrCh) |
                  for (@unfRevAddress <- revAddrCh) {
                    @AuthKey!("make", (*_bulletVault, unfRevAddress), *ret)
                  }
                }
              } |
              contract BulletVault(@"findOrCreate", @revAddress, retCh) = {
                new revAddressValidCh, revAddressValidEitherCh in {
                  RevAddress!("validate", revAddress, *revAddressValidCh) |
                  @Either!("fromNillableError <-", *revAddressValidCh, *revAddressValidEitherCh) |
                  for (@revAddressEither <- revAddressValidEitherCh) {
                    match revAddressEither {
                      (false, _) => {
                        retCh!(revAddressEither)
                      }
                      _ => {
                        new createVault, vaultCh, getVaultCh in {
                          TreeHashMap!("get", bulletMap, revAddress, *getVaultCh) |
                          for (@vault <- getVaultCh) {
                            if (vault != Nil) {
                              retCh!((true, vault))
                            } else {
                              _create!(revAddress, *createVault, *vaultCh) |
                              for (vaultRetCh <- createVault) {
                                _makeVault!(revAddress, 0, *vaultRetCh) |
                                for (@eitherVault <- vaultCh) {
                                  retCh!(eitherVault)
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              } |

              contract BulletVault(@"deposit", @amount, @rate, retCh) = {
                new DeployerIdOps(`rho:rchain:deployerId:ops`),
                    revAddrCh, deployerPubKeyBytesCh, deployerId(`rho:rchain:deployerId`)  
                in {
                  DeployerIdOps!("pubKeyBytes", *deployerId, *deployerPubKeyBytesCh) |
                  for (@deployerPubKeyBytes <- deployerPubKeyBytesCh) {
                    RevAddress!("fromPublicKey", deployerPubKeyBytes, *revAddrCh) |
                    for (@deployerRevAddress <- revAddrCh) {
                      new vaultCh, revVaultkeyCh in {
                        @RevVault!("findOrCreate", deployerRevAddress, *vaultCh) |
                        @RevVault!("deployerAuthKey", *deployerId, *revVaultkeyCh) |
                        for (@(true, vault) <- vaultCh; key <- revVaultkeyCh) {
                          // TODO: if the amount is below 10 REV, won't trigger.
                          new resultCh, ackCh, blockData(`rho:block:data`), tCh in {
                            @vault!("transfer", revHouseAddr, amount, *key, *resultCh) |
                            blockData!(*tCh) |
                            for (@result <- resultCh; @_, @t, @_ <- tCh) {
                              // TODO: If transfer failed,...
                              _depositList!("deposit", deployerRevAddress, {"timestamp":t,"amount":amount}, *ackCh)|
                              // send Bullet
                              new createVault, bulletVaultCh, balanceCh, vaultCh, vaultCh, getVaultCh in {
                                TreeHashMap!("get", bulletMap, deployerRevAddress, *getVaultCh) |
                                for (@vault <- getVaultCh) {
                                  if (vault != Nil) {
                                    @vault!("balance", *balanceCh)| 
                                    for (@balance <- balanceCh) {
                                      _create!(deployerRevAddress, *createVault, *bulletVaultCh) |
                                      for (vaultRetCh <- createVault) {
                                        _makeVault!(deployerRevAddress, amount / rate + balance, *vaultRetCh) |
                                        for (@eitherVault <- bulletVaultCh) {
                                          retCh!(eitherVault)
                                        }
                                      }
                                    }      
                                  } else {
                                    _create!(deployerRevAddress, *createVault, *bulletVaultCh) |
                                    for (vaultRetCh <- createVault) {
                                      _makeVault!(deployerRevAddress, amount / rate, *vaultRetCh) |
                                      for (@eitherVault <- bulletVaultCh) {
                                        retCh!(eitherVault)
                                      }
                                    }  
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  } 
                }       
              } |

              // contract BulletVault(@"withdraw", retCh) = {
              //   new DeployerIdOps(`rho:rchain:deployerId:ops`),
              //       revAddrCh, deployerPubKeyBytesCh, RevVaultCh, deployerId(`rho:rchain:deployerId`), getBalanceCh  
              //   in {
              //     DeployerIdOps!("pubKeyBytes", *deployerId, *deployerPubKeyBytesCh) |
              //     for (@deployerPubKeyBytes <- deployerPubKeyBytesCh) {
              //       RevAddress!("fromPublicKey", deployerPubKeyBytes, *revAddrCh) |
              //       for (@deployerRevAddress <- revAddrCh) {                         
              //         _depositList!("withdraw", deployerRevAddress, *retCh)
              //       }        
              //     }
              //   } 
              // } |  

              contract _depositList(@"deposit", @deployerRevAddress, @item, ackCh) = {
                new listCh in {
                  TreeHashMap!("get", revMap, deployerRevAddress, *listCh) |
                  for (@list <- listCh) {
                    if(list == Nil) {
                      TreeHashMap!("set", revMap, deployerRevAddress, [item], *ackCh) 
                    }else{
                      TreeHashMap!("set", revMap, deployerRevAddress, list ++ [item], *ackCh) 
                    }

                  }                
                }  
              } |

              // contract _depositList(@"withdraw", @deployerRevAddress, retCh) = {
              //   new blockData(`rho:block:data`), tCh, _remove, liCh, ret in {
              //     blockData!(*tCh) |
              //     TreeHashMap!("get", revMap, deployerRevAddress, *liCh) |
              //     for (@_, @t, @_ <- tCh; @li <- liCh) {
              //       if (li == [] or li == Nil) {
              //         deployId!("No record found!")
              //       } else{
              //         _remove!(t, li, *ret)
              //         |deployId!(["list: ", li])
              //       }
              //     }|
              //     contract _remove (newTimeStamp, items, ret) = {
              //       new resultCh, ack, removeAck in {
              //         if(*items != []){
              //           if (*items.nth(0).get("timestamp") < (*newTimeStamp - 200000)) {
              //             @revHouseVault!("transfer", deployerRevAddress, *items.nth(0).get("amount"), revHouseVaultAuthKey, *resultCh) |
              //             for (@res <- resultCh) {
              //               TreeHashMap!("set", revMap, deployerRevAddress, *items.slice(1,*items.length()), *ack) |
              //               for (@ackn <- ack) {
              //                 _remove!( *newTimeStamp, *items.slice(1,*items.length()), *removeAck)|
              //                 ret!(true)
              //                 |
              //                 new re1 in {
              //                   TreeHashMap!("get", revMap, deployerRevAddress, *re1) |
              //                   for (@r <- re1) {
              //                     deployId!(["The removing result: ", r])
              //                   }
              //                 }  
              //               }
              //             }
              //           }else{
              //             ret!(true)|
              //             retCh!(true)|
              //             new re in {
              //               TreeHashMap!("get", revMap, deployerRevAddress, *re) |
              //               for (@lis <- re) {
              //                   deployId!(["Final result:", lis])
              //                 }
              //             }    
              //           } 
              //         }                      
              //       }       
              //     }  
              //   }
              // } |  
              contract _create(@revAddress, constructor, retCh) = {
                // The vault was not found, create a new one and set it in the bulletMap.
                new resCh, ackCh in {
                  constructor!(*resCh) |
                  for (@eitherVault <- resCh) {
                    match eitherVault {
                      (true, vault) => {
                        TreeHashMap!("set", bulletMap, revAddress, vault, *ackCh) |
                        for (_ <- ackCh) {
                          retCh!(eitherVault)
                        }
                      }
                      (false, _)    => {
                        retCh!(eitherVault)
                      }
                    }
                  }
                }
              } |
              contract _makeVault(@ownerRevAddress, @initialAmount, ret) = {
                new revAddrCh, eitherRevAddrCh, purseCh, eitherPurseCh, mkVault in {
                  @Either!("fromNillable", ownerRevAddress, "Required `revAddress` parameter was Nil", *eitherRevAddrCh) |
                  mint!("makePurse", initialAmount, *purseCh) |
                  @Either!("fromNillable <-", *purseCh, "Couldn't create purse", *eitherPurseCh) |
                  @Either!("map2 <-", *eitherRevAddrCh, *eitherPurseCh,
                    for (@addr, purse, r <- mkVault) {
                      new bulletVault in {
                        _newVault!(*bulletVault, addr, *purse) |
                        r!(bundle+{*bulletVault})
                      }
                    },
                    *ret
                  )
                }
              } |
              contract _newVault(bulletVault, @ownRevAddress, purse) = {
                new logStore in {
                  logStore!(Nil) |
                  contract bulletVault(@"balance", ret) = {
                    purse!("getBalance", *ret)
                  } |
                  contract bulletVault(@"transfer", @revAddress, @amount, authKey, ret) = {
                    new ret2 in {
                      _transferTemplate!(ownRevAddress, *purse, revAddress, amount, *authKey, *ret2) |
                      for (@result <- ret2) {
                        ret!(result) |
                        for (logCh <<- logStore) {
                          if (Nil != *logCh) {
                            new bd(`rho:block:data`), bdCh in {
                              bd!(*bdCh) |
                              for (@blockNumber, @timestamp, @sender <- bdCh) {
                                logCh!(["transfer", revAddress, amount, result, blockNumber, timestamp, sender])
                              }
                            }
                          }
                        }
                      }
                    }
                  } |
                  contract bulletVault(@"setLog", logCh, authKey, ret) = {
                    new authKeyValidCh in {
                      @AuthKey!("check", *authKey, (*_bulletVault, ownRevAddress), *authKeyValidCh) |
                      for (@result <- authKeyValidCh) {
                        if (result) {
                          new ack in {
                            for (_ <- logStore) {
                              logStore!(*logCh) |
                              purse!("setLog", *logCh, *ack) |
                              for (_ <- ack) {
                                ret!(true)
                              }
                            }
                          }
                        } else {
                          ret!(false)
                        }
                      }
                    }
                  } |
                  contract @{ownRevAddress | bundle0{*_bulletVault}}(@"_deposit", depositPurse, retCh) = {
                    _depositTemplate!(*purse, *depositPurse, *retCh)
                  }
                }
              } |
              contract _transferTemplate(@ownRevAddress, purse, @revAddress, @amount, authKey, ret) = {
                new revAddressValid, revAddressValidEither, amountNonNegative,
                    authKeyValidCh, authKeyValidEitherCh,
                    parametersOkCh, parametersAndAuthOkCh,
                    split, eitherPurseCh, doDeposit
                in {
                  RevAddress!("validate", revAddress, *revAddressValid) |
                  @Either!("fromNillableError <-", *revAddressValid, *revAddressValidEither) |
                  @Either!("fromBoolean", amount >= 0, "Amount must be non-negative", *amountNonNegative) |
                  @AuthKey!("check", *authKey, (*_bulletVault, ownRevAddress), *authKeyValidCh) |
                  @Either!("fromBoolean <-", *authKeyValidCh, "Invalid AuthKey", *authKeyValidEitherCh) |
                  @Either!("productR <-", *revAddressValidEither, *amountNonNegative, *parametersOkCh) |
                  @Either!("productR <-", *parametersOkCh, *authKeyValidEitherCh, *parametersAndAuthOkCh) |
                  @Either!("flatMap <-", *parametersAndAuthOkCh, *split, *eitherPurseCh) |
                  for (_, retCh <- split) {
                    new amountPurseCh in {
                      purse!("split", amount, *amountPurseCh) |
                      @Either!("fromSingletonList <-", *amountPurseCh, "Insufficient funds", *retCh)
                    }
                  } |
                  @Either!("flatMap <-", *eitherPurseCh, *doDeposit, *ret) |
                  for (@p, retCh <- doDeposit) {
                    @{revAddress | bundle0{*_bulletVault}}!("_deposit", p, *retCh)
                  }
                }
              } |
              contract _depositTemplate(toPurse, fromPurse, retCh) = {
                new amountCh, depositSuccessCh in {
                  fromPurse!("getBalance", *amountCh) |
                  for (@amount <- amountCh) {
                    toPurse!("deposit", amount, *fromPurse, *depositSuccessCh) |
                    @Either!("fromBoolean <-", *depositSuccessCh, "BUG FOUND: purse deposit failed", *retCh)
                  }
                }
              } 
              |
              insertArbitrary!(bundle+{*BulletVault}, *uriOut) |
              for(@uri <- uriOut) {
                stdout!("Bullet here:")|
                stdout!(uri)|
                deployId!(uri)// |
              }
            }
          }
        }
      }
    }
  }
}      , Sig: 30450221008d080edb49...6dc33be3eff62ec9a968, SigAlgorithm: secp256k1, ValidAfterBlockNumber: -1
2023-11-19 06:34:36,521 [DEBUG] [c-nio-worker-ELG-3-1] [io.perfmark.PerfMark         ]- Error during PerfMark.<clinit>
java.lang.ClassNotFoundException: io.perfmark.impl.SecretPerfMarkImpl$PerfMarkImpl
	at java.base/jdk.internal.loader.BuiltinClassLoader.loadClass(BuiltinClassLoader.java:581)
	at java.base/jdk.internal.loader.ClassLoaders$AppClassLoader.loadClass(ClassLoaders.java:178)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:527)
	at java.base/java.lang.Class.forName0(Native Method)
	at java.base/java.lang.Class.forName(Class.java:315)
	at io.perfmark.PerfMark.<clinit>(PerfMark.java:36)
	at io.grpc.netty.NettyServerStream$TransportState.<init>(NettyServerStream.java:225)
	at io.grpc.netty.NettyServerHandler.onHeadersRead(NettyServerHandler.java:439)
	at io.grpc.netty.NettyServerHandler.access$900(NettyServerHandler.java:101)
	at io.grpc.netty.NettyServerHandler$FrameListener.onHeadersRead(NettyServerHandler.java:813)
	at io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$FrameReadListener.onHeadersRead(DefaultHttp2ConnectionDecoder.java:373)
	at io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$FrameReadListener.onHeadersRead(DefaultHttp2ConnectionDecoder.java:321)
	at io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$PrefaceFrameListener.onHeadersRead(DefaultHttp2ConnectionDecoder.java:665)
	at io.netty.handler.codec.http2.Http2InboundFrameLogger$1.onHeadersRead(Http2InboundFrameLogger.java:56)
	at io.netty.handler.codec.http2.DefaultHttp2FrameReader$2.processFragment(DefaultHttp2FrameReader.java:483)
	at io.netty.handler.codec.http2.DefaultHttp2FrameReader.readHeadersFrame(DefaultHttp2FrameReader.java:491)
	at io.netty.handler.codec.http2.DefaultHttp2FrameReader.processPayloadState(DefaultHttp2FrameReader.java:254)
	at io.netty.handler.codec.http2.DefaultHttp2FrameReader.readFrame(DefaultHttp2FrameReader.java:160)
	at io.netty.handler.codec.http2.Http2InboundFrameLogger.readFrame(Http2InboundFrameLogger.java:41)
	at io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder.decodeFrame(DefaultHttp2ConnectionDecoder.java:174)
	at io.netty.handler.codec.http2.Http2ConnectionHandler$FrameDecoder.decode(Http2ConnectionHandler.java:378)
	at io.netty.handler.codec.http2.Http2ConnectionHandler$PrefaceDecoder.decode(Http2ConnectionHandler.java:242)
	at io.netty.handler.codec.http2.Http2ConnectionHandler.decode(Http2ConnectionHandler.java:438)
	at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:498)
	at io.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:437)
	at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:276)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357)
	at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1410)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)
	at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:919)
	at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:163)
	at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:714)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:650)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:576)
	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:493)
	at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:989)
	at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)
	at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
	at java.base/java.lang.Thread.run(Thread.java:829)
2023-11-19 06:34:36,559 [INFO ] [node-runner-19      ] [c.r.n.i.ProposerInstance$    ]- Propose started
2023-11-19 06:34:36,560 [DEBUG] [node-runner-38      ] [c.rchain.casper.api.BlockAPI$]- Failure: another propose is in progress
2023-11-19 06:34:37,523 [INFO ] [node-runner-37      ] [c.r.c.b.proposer.Proposer    ]- getCasperSnapshot [957.104896 ms]
2023-11-19 06:34:37,532 [INFO ] [node-runner-27      ] [alizedHeightConstraintChecker]- Latest message is 0 blocks ahead of the last finalized block
2023-11-19 06:34:37,552 [INFO ] [node-runner-29      ] [c.r.c.b.p.BlockCreator$      ]- Creating block #1 (seqNum 1)
2023-11-19 06:34:37,637 [INFO ] [node-runner-25      ] [c.r.casper.rholang.RuntimeOps]- PreCharging 04be064356846e36e485408df50b877dd99ba406d87208add4c92b3c7d4e4c663c2fbc6a1e6534c7e5c0aec00b26486fad1daf20079423b7c8ebffbbdff3682b58 for 100000000
2023-11-19 06:34:39,663 [DEBUG] [node-runner-24      ] [coop.rchain.rholang.stdout   ]- `rho:id:q93wo3kskhgeqwdyys5deyki7whutqofd373yayn7bthgmsjf9cib5`
2023-11-19 06:34:39,663 [DEBUG] [node-runner-29      ] [coop.rchain.rholang.stdout   ]- "NEC here:"
2023-11-19 06:34:39,669 [INFO ] [node-runner-29      ] [c.r.casper.rholang.RuntimeOps]- Refunding 04be064356846e36e485408df50b877dd99ba406d87208add4c92b3c7d4e4c663c2fbc6a1e6534c7e5c0aec00b26486fad1daf20079423b7c8ebffbbdff3682b58 with 99431675
2023-11-19 06:34:40,073 [INFO ] [node-runner-25      ] [c.r.casper.rholang.RuntimeOps]- PreCharging 04be064356846e36e485408df50b877dd99ba406d87208add4c92b3c7d4e4c663c2fbc6a1e6534c7e5c0aec00b26486fad1daf20079423b7c8ebffbbdff3682b58 for 100000000
2023-11-19 06:34:41,693 [DEBUG] [node-runner-19      ] [coop.rchain.rholang.stdout   ]- "Bullet here:"
2023-11-19 06:34:41,694 [DEBUG] [node-runner-27      ] [coop.rchain.rholang.stdout   ]- `rho:id:96mnxtyedk8ra5iwc7ouwbkyinwqxkbqom9kr4ry49fwsm3y6eidzg`
2023-11-19 06:34:41,697 [INFO ] [node-runner-38      ] [c.r.casper.rholang.RuntimeOps]- Refunding 04be064356846e36e485408df50b877dd99ba406d87208add4c92b3c7d4e4c663c2fbc6a1e6534c7e5c0aec00b26486fad1daf20079423b7c8ebffbbdff3682b58 with 99420030
2023-11-19 06:34:42,931 [INFO ] [node-runner-25      ] [c.r.c.b.p.BlockCreator$      ]- Block created: #1 (dc19eb523d...) (2d) [5.381035502 sec]
2023-11-19 06:34:42,940 [INFO ] [node-runner-25      ] [c.r.c.MultiParentCasperImpl  ]- Validating block #1 (dc19eb523d...).
2023-11-19 06:34:43,038 [INFO ] [node-runner-25      ] [c.r.c.u.r.InterpreterUtil$   ]- Computed parents post state for Block #1 (dc19eb523d...) -- Sender ID 042e13eadc... -- M Parent Hash af02b030eb... -- Contents 63aa233cdd...-- Shard ID root.
2023-11-19 06:34:45,376 [DEBUG] [node-runner-24      ] [coop.rchain.rholang.stdout   ]- `rho:id:q93wo3kskhgeqwdyys5deyki7whutqofd373yayn7bthgmsjf9cib5`
2023-11-19 06:34:45,377 [DEBUG] [node-runner-38      ] [coop.rchain.rholang.stdout   ]- "NEC here:"
2023-11-19 06:34:47,450 [DEBUG] [node-runner-25      ] [coop.rchain.rholang.stdout   ]- `rho:id:96mnxtyedk8ra5iwc7ouwbkyinwqxkbqom9kr4ry49fwsm3y6eidzg`
2023-11-19 06:34:47,451 [DEBUG] [node-runner-19      ] [coop.rchain.rholang.stdout   ]- "Bullet here:"
2023-11-19 06:34:48,404 [INFO ] [node-runner-27      ] [c.r.c.EquivocationDetector$  ]- Calculate checkNeglectedEquivocationsWithUpdate
2023-11-19 06:34:48,408 [INFO ] [node-runner-27      ] [c.r.c.EquivocationDetector$  ]- Calculate checkEquivocations.
2023-11-19 06:34:48,412 [INFO ] [node-runner-27      ] [c.r.c.MultiParentCasperImpl  ]- Block replayed: #1 (dc19eb523d...) (2d) (Valid) [5.470177925 sec]
2023-11-19 06:34:49,355 [INFO ] [node-runner-38      ] [c.r.c.MultiParentCasperImpl  ]- Removed 0 deploys from deploy history as we finalized block [af02b030eb...].
2023-11-19 06:34:49,370 [INFO ] [node-runner-38      ] [.r.c.e.BlockRetriever$$anon$1]- Block dc19eb523d... is not in RequestedBlocks. Adding and marking recieved.
2023-11-19 06:34:49,376 [INFO ] [node-runner-38      ] [c.r.c.util.comm.CommUtilOps  ]- Sent hash dc19eb523d... to peers
2023-11-19 06:34:49,388 [INFO ] [node-runner-27      ] [c.rchain.casper.api.BlockAPI$]- Success! Block dc19eb523da1dc724cca50921db1ea346d447276b6726a54b25de4e0a8ddc89e created and added.
2023-11-19 06:34:49,390 [INFO ] [node-runner-38      ] [c.r.n.i.ProposerInstance$    ]- Propose finished: ProposeSuccess(Valid) Block #1 (dc19eb523d...) created and added.
2023-11-19 06:34:49,395 [INFO ] [node-runner-26      ] [c.r.n.i.ProposerInstance$    ]- Propose started
2023-11-19 06:34:49,701 [INFO ] [node-runner-26      ] [c.r.c.b.proposer.Proposer    ]- getCasperSnapshot [306.019509 ms]
2023-11-19 06:34:49,703 [INFO ] [node-runner-38      ] [alizedHeightConstraintChecker]- Latest message is 1 blocks ahead of the last finalized block
2023-11-19 06:34:49,958 [INFO ] [node-runner-25      ] [.c.SynchronyConstraintChecker]- Seen 0 senders with weight 0 out of total 100002000000 (0.0 out of 0.0 needed)
2023-11-19 06:34:49,960 [INFO ] [node-runner-19      ] [c.r.c.b.p.BlockCreator$      ]- Creating block #2 (seqNum 2)
2023-11-19 06:34:49,962 [INFO ] [node-runner-19      ] [c.r.n.i.ProposerInstance$    ]- Propose failed: NoNewDeploys
2023-11-19 06:35:02,290 [DEBUG] [node-runner-27      ] [c.r.c.MultiParentCasperImpl  ]- Requesting CasperBuffer pendant hashes, 0 items.
2023-11-19 06:35:02,290 [DEBUG] [node-runner-27      ] [.r.c.e.BlockRetriever$$anon$1]- Running BlockRetriever maintenance (1 items unexpired).
2023-11-19 06:35:32,296 [DEBUG] [node-runner-19      ] [c.r.c.MultiParentCasperImpl  ]- Requesting CasperBuffer pendant hashes, 0 items.
2023-11-19 06:35:32,297 [DEBUG] [node-runner-19      ] [.r.c.e.BlockRetriever$$anon$1]- Running BlockRetriever maintenance (1 items unexpired).
2023-11-19 06:35:51,769 [DEBUG] [node-runner-29      ] [c.r.c.safety.CliqueOracle$   ]- Calculating fault tolerance for dc19eb523da1dc724cca50921db1ea346d447276b6726a54b25de4e0a8ddc89e.
2023-11-19 06:35:51,841 [INFO ] [node-runner-29      ] [c.r.c.MultiParentCasperImpl  ]- Received DeployData #1700375751713 -- new userCh, print(`rho:io:stdout`), ret in {
    contract @{"rl_factory"}(checkBalance, transfer, checkBulletBalance, depositForBullet, checkNECBalance, depositForNEC) = {
        contract checkBalance(addr, ret) = {
            new rl(`rho:registry:lookup`), RevVaultCh, vaultCh, balanceCh in {
                rl!(`rho:rchain:revVault`, *RevVaultCh) |
                for (@(_, RevVault) <- RevVaultCh) {
                    match *addr {
                        revAddress => {
                            print!(("Accessing vault at RevAddress", revAddress)) |
                            @RevVault!("findOrCreate", revAddress, *vaultCh) |
                            for (@(true, vault) <- vaultCh) {
                                print!("Obtained vault, checking balance") |
                                @vault!("balance", *balanceCh) |
                                for (@balance <- balanceCh) {
                                    ret!(balance)
                                }
                            }
                        }
                    }
                }
            }
        }
        |
        contract transfer(from, to, amount) = {
            new rl(`rho:registry:lookup`), RevVaultCh in {
                rl!(`rho:rchain:revVault`, *RevVaultCh) |
                for (@(_, RevVault) <- RevVaultCh) {
                    match (
                        *from,
                        *to,
                        *amount
                    ) {
                        (from, to, amount) => {
                            new vaultCh, targetVaultCh, revVaultkeyCh, deployerId(`rho:rchain:deployerId`) in {
                                @RevVault!("findOrCreate", from, *vaultCh) |
                                @RevVault!("findOrCreate", to, *targetVaultCh) |
                                @RevVault!("deployerAuthKey", *deployerId, *revVaultkeyCh) |
                                for (@(true, vault) <- vaultCh ; key <- revVaultkeyCh ; @(true, _) <- targetVaultCh) {
                                    print!(("Beginning transfer of ", amount, "REV from", from, "to", to)) |
                                    new resultCh in {
                                        @vault!("transfer", to, amount, *key, *resultCh) |
                                        for (@result <- resultCh) {
                                            print!(("Finished transfer of ", amount, "REV to", to, "result was:", result))
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        |
        contract checkBulletBalance(addr, ret) = {
            new rl(`rho:registry:lookup`), BulletVaultCh, vaultCh, balanceCh, res in {
                rl!(`rho:id:96mnxtyedk8ra5iwc7ouwbkyinwqxkbqom9kr4ry49fwsm3y6eidzg`, *BulletVaultCh) |
                for (@BulletVault <- BulletVaultCh) {
                    match *addr {
                        revAddress => {
                            print!(("Accessing BulletVault at RevAddress", revAddress)) |
                            @BulletVault!("findOrCreate", revAddress, *vaultCh) |
                            // @BulletVault!("test", *res)|
                            // @"BulletVault"!("findOrCreate", *addr, *vaultCh) |
                            for (@(true, vault) <- vaultCh) {
                                print!("Obtained vault, checking balance") |
                                @vault!("balance", *balanceCh) |
                                for (@balance <- balanceCh) {
                                    ret!(balance)
                                }
                            }
                        }
                    }
                }
            }
        }
        |
        contract depositForBullet(amount, rate) = {
            new rl(`rho:registry:lookup`), BulletVaultCh, retCh in {
                rl!(`rho:id:96mnxtyedk8ra5iwc7ouwbkyinwqxkbqom9kr4ry49fwsm3y6eidzg`, *BulletVaultCh) |
                for (@BulletVault <- BulletVaultCh) {
                    match (*amount, *rate){
                        (amount, rate) => {
                            print!("start deposit")|
                            @BulletVault!("deposit", amount, rate, *retCh) |
                            for (@result <- retCh) {
                                print!(("Finished deposit, pay amount: ", amount))
                            }
                        }
                    }
                }
            }
        }
        |
        contract checkNECBalance(addr, ret) = {
            new rl(`rho:registry:lookup`), NecVaultCh, vaultCh, balanceCh, res in {
                rl!(`rho:id:q93wo3kskhgeqwdyys5deyki7whutqofd373yayn7bthgmsjf9cib5`, *NecVaultCh) |
                for (@NecVault <- NecVaultCh) {
                    match *addr {
                        revAddress => {
                            print!(("Accessing NECVault at RevAddress", revAddress)) |
                            @NecVault!("findOrCreate", revAddress, *vaultCh) |
                            // @NecVault!("test", *res)|
                            // @"NecVault"!("findOrCreate", *addr, *vaultCh) |
                            for (@(true, vault) <- vaultCh) {
                                print!("Obtained vault, checking balance") |
                                @vault!("balance", *balanceCh) |
                                for (@balance <- balanceCh) {
                                    ret!(balance)
                                }
                            }
                        }
                    }
                }
            }
        }
        |
        contract depositForNEC(amount, rate) = {
            new rl(`rho:registry:lookup`), NecVaultCh, retCh in {
                rl!(`rho:id:q93wo3kskhgeqwdyys5deyki7whutqofd373yayn7bthgmsjf9cib5`, *NecVaultCh) |
                for (@NecVault <- NecVaultCh) {
                    match (*amount, *rate){
                        (amount, rate) => {
                            print!("start deposit")|
                            @NecVault!("deposit", amount, rate, *retCh) |
                            for (@result <- retCh) {
                                print!(("Finished deposit, pay amount: ", amount))
                            }
                        }
                    }
                }
            }
        }
    }
}, Sig: 304402205fe915bf9782...815fe9135846f22eac11, SigAlgorithm: secp256k1, ValidAfterBlockNumber: 1
2023-11-19 06:35:51,866 [INFO ] [node-runner-27      ] [c.r.n.i.ProposerInstance$    ]- Propose started
2023-11-19 06:35:52,085 [INFO ] [node-runner-37      ] [c.r.c.b.proposer.Proposer    ]- getCasperSnapshot [218.986133 ms]
2023-11-19 06:35:52,087 [INFO ] [node-runner-27      ] [alizedHeightConstraintChecker]- Latest message is 1 blocks ahead of the last finalized block
2023-11-19 06:35:52,308 [INFO ] [node-runner-19      ] [.c.SynchronyConstraintChecker]- Seen 0 senders with weight 0 out of total 100002000000 (0.0 out of 0.0 needed)
2023-11-19 06:35:52,310 [INFO ] [node-runner-19      ] [c.r.c.b.p.BlockCreator$      ]- Creating block #2 (seqNum 2)
2023-11-19 06:35:52,346 [INFO ] [node-runner-37      ] [c.r.casper.rholang.RuntimeOps]- PreCharging 04be064356846e36e485408df50b877dd99ba406d87208add4c92b3c7d4e4c663c2fbc6a1e6534c7e5c0aec00b26486fad1daf20079423b7c8ebffbbdff3682b58 for 100000000
2023-11-19 06:35:52,877 [INFO ] [node-runner-29      ] [c.r.casper.rholang.RuntimeOps]- Refunding 04be064356846e36e485408df50b877dd99ba406d87208add4c92b3c7d4e4c663c2fbc6a1e6534c7e5c0aec00b26486fad1daf20079423b7c8ebffbbdff3682b58 with 99981368
2023-11-19 06:35:53,766 [INFO ] [node-runner-19      ] [c.r.c.b.p.BlockCreator$      ]- Block created: #2 (1c7acf53cb...) (1d) [1.456344038 sec]
2023-11-19 06:35:53,767 [INFO ] [node-runner-19      ] [c.r.c.MultiParentCasperImpl  ]- Validating block #2 (1c7acf53cb...).
2023-11-19 06:35:53,823 [INFO ] [node-runner-19      ] [c.r.c.u.r.InterpreterUtil$   ]- Computed parents post state for Block #2 (1c7acf53cb...) -- Sender ID 042e13eadc... -- M Parent Hash dc19eb523d... -- Contents 74ebcc3790...-- Shard ID root.
2023-11-19 06:35:55,265 [INFO ] [node-runner-27      ] [c.r.c.EquivocationDetector$  ]- Calculate checkNeglectedEquivocationsWithUpdate
2023-11-19 06:35:55,265 [INFO ] [node-runner-27      ] [c.r.c.EquivocationDetector$  ]- Calculate checkEquivocations.
2023-11-19 06:35:55,266 [INFO ] [node-runner-27      ] [c.r.c.MultiParentCasperImpl  ]- Block replayed: #2 (1c7acf53cb...) (1d) (Valid) [1.497793119 sec]
2023-11-19 06:35:55,417 [INFO ] [node-runner-26      ] [c.r.c.MultiParentCasperImpl  ]- Removed 0 deploys from deploy history as we finalized block [af02b030eb...].
2023-11-19 06:35:55,425 [INFO ] [node-runner-26      ] [.r.c.e.BlockRetriever$$anon$1]- Block 1c7acf53cb... is not in RequestedBlocks. Adding and marking recieved.
2023-11-19 06:35:55,426 [INFO ] [node-runner-26      ] [c.r.c.util.comm.CommUtilOps  ]- Sent hash 1c7acf53cb... to peers
2023-11-19 06:35:55,427 [INFO ] [node-runner-29      ] [c.rchain.casper.api.BlockAPI$]- Success! Block 1c7acf53cb09e0590adcd283ef8b95ea66dc3ca45ab9fb2c95114f24aa0d7731 created and added.
2023-11-19 06:35:55,427 [INFO ] [node-runner-26      ] [c.r.n.i.ProposerInstance$    ]- Propose finished: ProposeSuccess(Valid) Block #2 (1c7acf53cb...) created and added.
2023-11-19 06:36:02,308 [DEBUG] [node-runner-19      ] [c.r.c.MultiParentCasperImpl  ]- Requesting CasperBuffer pendant hashes, 0 items.
2023-11-19 06:36:02,308 [DEBUG] [node-runner-19      ] [.r.c.e.BlockRetriever$$anon$1]- Running BlockRetriever maintenance (2 items unexpired).
